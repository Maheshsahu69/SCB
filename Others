import React from "react";
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import { Provider } from "react-redux";
import configureStore from "redux-mock-store";
import Fields from "./fields";
import { stagesAction } from "../../../utils/store/stages-slice";
import { fieldErrorAction } from "../../../utils/store/field-error-slice";
import { errorAction } from "../../../utils/store/error-slice";
import { ValueUpdateAction } from "../../../utils/store/value-update-slice";
import { ContinueBtnAction } from "../../../utils/store/continue-validation-slice";

jest.mock("../../../services/track-events", () => ({
  triggerAdobeEvent: jest.fn(),
}));

jest.mock("../../../services/common-service", () => ({
  dispatchError: jest.fn(),
  ibankEncrypt: jest.fn(() => Promise.resolve({ status: 200 })),
  isFormUpdate: jest.fn(),
  lovRequests: jest.fn(),
}));

jest.mock("../../../utils/store/stages-slice", () => ({
  stagesAction: {
    updateStageId: jest.fn(),
    getStage: jest.fn(),
    resetNewAndOldFields: jest.fn(),
    setOtpShow: jest.fn(),
    modifyStage: jest.fn(),
    updateDynamicCityField: jest.fn(),
  },
}));

jest.mock("../../../utils/store/field-error-slice", () => ({
  fieldErrorAction: {
    getMandatoryFields: jest.fn(),
    getFieldError: jest.fn(),
    removeToggleFieldError: jest.fn(),
  },
}));

jest.mock("../../../utils/store/error-slice", () => ({
  errorAction: {
    getExceptionList: jest.fn(),
    toggleSubmit: jest.fn(),
  },
}));

jest.mock("../../../utils/store/value-update-slice", () => ({
  ValueUpdateAction: {
    getChangeUpdate: jest.fn(),
  },
}));

jest.mock("../../../utils/store/continue-validation-slice", () => ({
  ContinueBtnAction: {
    getContinueEnableState: jest.fn(),
  },
}));

const mockStore = configureStore([]);

describe("Fields Component", () => {
  let store: any;

  beforeEach(() => {
    store = mockStore({
      stages: {
        stages: [{ stageId: "bd-1", stageInfo: { products: [{ product_type: "PL" }] } }],
        parentChildFields: { selectFields: [] },
        userInput: { applicants: [{ work_type: "S001", priority_banking: "No" }] },
        currentStage: "bd-1",
        journeyType: "ETC",
      },
      valueUpdate: { changesUpdate: { changes: false }, value: false },
      fielderror: { mandatoryFields: [], error: [] },
      continueBtnSlice: { continueEnable: true },
      error: { submit: false },
      preApproval: { currentStage: "BD" },
      urlParam: { resume: false },
    });

    store.dispatch = jest.fn();
  });

  it("renders Fields component correctly", () => {
    render(
      <Provider store={store}>
        <Fields />
      </Provider>
    );

    expect(screen.getByRole("form")).toBeInTheDocument();
  });

  it("triggers handleSubmit on form submission", async () => {
    render(
      <Provider store={store}>
        <Fields />
      </Provider>
    );

    const form = screen.getByRole("form");
    fireEvent.submit(form);

    await waitFor(() => {
      expect(store.dispatch).toHaveBeenCalledWith(expect.any(Function));
    });
  });

  it("triggers backHandler on clicking back button", async () => {
    render(
      <Provider store={store}>
        <Fields />
      </Provider>
    );

    const backButton = screen.getByText("Back");
    fireEvent.click(backButton);

    await waitFor(() => {
      expect(stagesAction.updateStageId).toHaveBeenCalled();
    });
  });

  it("dispatches error when form validation fails", async () => {
    store = mockStore({
      ...store,
      fielderror: { mandatoryFields: ["field1"] },
      valueUpdate: { value: true },
    });

    render(
      <Provider store={store}>
        <Fields />
      </Provider>
    );

    const form = screen.getByRole("form");
    fireEvent.submit(form);

    await waitFor(() => {
      expect(fieldErrorAction.getFieldError).toHaveBeenCalled();
    });
  });

  it("dispatches setOtpShow when stage is PD_1", async () => {
    store = mockStore({
      ...store,
      stages: { ...store.stages, currentStage: "PD_1" },
    });

    render(
      <Provider store={store}>
        <Fields />
      </Provider>
    );

    const form = screen.getByRole("form");
    fireEvent.submit(form);

    await waitFor(() => {
      expect(stagesAction.setOtpShow).toHaveBeenCalledWith(true);
    });
  });

  it("calls handleFieldDispatch correctly", async () => {
    render(
      <Provider store={store}>
        <Fields />
      </Provider>
    );

    const input = document.createElement("input");
    input.setAttribute("name", "field1");
    input.setAttribute("value", "newValue");

    fireEvent.change(input);

    await waitFor(() => {
      expect(stagesAction.modifyStage).toHaveBeenCalled();
    });
  });

  it("updates form validation on input change", async () => {
    render(
      <Provider store={store}>
        <Fields />
      </Provider>
    );

    const input = document.createElement("input");
    input.setAttribute("name", "field1");
    input.setAttribute("value", "newValue");

    fireEvent.change(input);

    await waitFor(() => {
      expect(stagesAction.modifyStage).toHaveBeenCalled();
    });
  });

  it("renders FundDisbursement component when stage is LD_1", async () => {
    store = mockStore({
      ...store,
      stages: { ...store.stages, currentStage: "LD_1" },
    });

    render(
      <Provider store={store}>
        <Fields />
      </Provider>
    );

    expect(screen.getByText("Fund Disbursement")).toBeInTheDocument();
  });

  it("renders ReviewPage component when stage is RP", async () => {
    store = mockStore({
      ...store,
      stages: { ...store.stages, currentStage: "RP" },
    });

    render(
      <Provider store={store}>
        <Fields />
      </Provider>
    );

    expect(screen.getByText("Review Page")).toBeInTheDocument();
  });
});
