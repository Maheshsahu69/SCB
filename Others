 describe("postDocuments", () => {
    beforeEach(() => {
      mockedAxios.post.mockReset();
      (PreApprovalUtil.getAckMetaData as jest.Mock).mockReturnValue(
        "mocked_ack_meta_data"
      );
    });

    it("should call axios.post with correct arguments and resolve", async () => {
      // Mock environment variables
      process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
      process.env.REACT_APP_RTOB_APPLICATION_END_POINT =
        "/application-endpoint/";
      process.env.REACT_APP_RTOB_DOCUMENTS_END_POINT = "/documents-endpoint/";

      const mockedResponse = { data: "mocked_response" };
      mockedAxios.post.mockResolvedValueOnce(mockedResponse);

      const channelReference = "mocked_channel_ref";
      const file = new File(["dummy content"], "testDocument.pdf", {
        type: "application/pdf",
      });

      const result = await postDocuments(channelReference, file);
      expect(result).toEqual(mockedResponse);

      // Check FormData contents
      const formData = new FormData();
      formData.append("file", file, "testDocument.pdf");
      formData.append(
        "documentJson",
        JSON.stringify({
          origin: "front-line-supporting-document",
          documentCategoryCode: "R0005",
          documentTypeCode: "A023",
          applicantId: 1,
          imageOrder: 5,
          period: 0,
          isWatermarkRequired: "N",
          documentOptionSequence: "undefined",
        })
      );
    });
    it("should handle axios.post rejection and call dispatchError", async () => {
      // Mock environment variables
      process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
      process.env.REACT_APP_RTOB_APPLICATION_END_POINT =
        "/application-endpoint/";
      process.env.REACT_APP_RTOB_DOCUMENTS_END_POINT = "/documents-endpoint/";

      const mockedError = new Error("mocked_error");
      mockedAxios.post.mockRejectedValueOnce(mockedError);

      const channelReference = "mocked_channel_ref";
      const file = new File(["dummy content"], "testDocument.pdf", {
        type: "application/pdf",
      });

      await expect(postDocuments(channelReference, file)).rejects.toThrow(
        "mocked_error"
      );

      expect(dispatchError).toHaveBeenCalledWith(mockedError);
    });
   });




export const postDocuments = (channelReference: any, file: any): any => {
  const imageOrder = JSON.parse(JSON.stringify(store.getState().preApproval.incomeProofDocumentUpload));
  
  console.log("store:----", store.getState())
  const documentJson: any = {
    origin: "front-line-supporting-document",
    documentCategoryCode: "R0005",
    documentTypeCode: "A023",
    applicantId: 1,
    imageOrder: imageOrder?.length + 1,
    period: 0,
    isWatermarkRequired: "Y",
    documentOptionSequence: "undefined",
  };

  console.log("----",  "imageOrder :",imageOrder);

  const baseUrl = `${process.env.REACT_APP_RTOB_BASE_URL}`;
  const endPoint = `${process.env.REACT_APP_RTOB_DOCUMENTS_END_POINT}`;
  const application = `${process.env.REACT_APP_RTOB_APPLICATION_END_POINT}`;

  const url = baseUrl + application + channelReference + endPoint;


  let data = new FormData();
  data.append("file", file);
  data.append("documentJson", JSON.stringify(documentJson));

  const options = {
    method: "POST",
    url,
    headers: {
      "Content-Type": "multipart/form-data",
      "Sc-Client-Context": PreApprovalUtil.getAckMetaData(channelReference),
    },
    body: JSON.stringify(data),
  };
const docaxios = axios.create({
    headers: options.headers,
  });

   return docaxios
   .post(url, data, options)
   .then((response: any) => {
          return Promise.resolve(response);
        })
        .catch((error: any) => {
          dispatchError(error);
          console.log("clientResponse", error);
          return Promise.reject(error);
        });

  }







import axios from "axios";
import { postDocuments } from "path_to_postDocuments";
import PreApprovalUtil from "path_to_util";
import { dispatchError } from "path_to_error_handling";

jest.mock("axios");
jest.mock("path_to_error_handling", () => ({
  dispatchError: jest.fn(),
}));
jest.mock("path_to_util", () => ({
  getAckMetaData: jest.fn(),
}));

const mockedAxios = axios as jest.Mocked<typeof axios>;

describe("postDocuments", () => {
  beforeEach(() => {
    mockedAxios.post.mockReset();
    (PreApprovalUtil.getAckMetaData as jest.Mock).mockReturnValue(
      "mocked_ack_meta_data"
    );
  });

  it("should call axios.post with correct arguments and resolve", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT =
      "/application-endpoint/";
    process.env.REACT_APP_RTOB_DOCUMENTS_END_POINT = "/documents-endpoint/";

    const mockedResponse = { data: "mocked_response" };
    mockedAxios.post.mockResolvedValueOnce(mockedResponse);

    const channelReference = "mocked_channel_ref";
    const file = new File(["dummy content"], "testDocument.pdf", {
      type: "application/pdf",
    });

    const result = await postDocuments(channelReference, file);
    expect(result).toEqual(mockedResponse);

    // Validate axios.post call arguments
    expect(mockedAxios.post).toHaveBeenCalledWith(
      "https://mock-base-url/application-endpoint/mocked_channel_ref/documents-endpoint/",
      expect.any(FormData),
      {
        headers: {
          "Sc-Client-Context": "mocked_ack_meta_data",
        },
      }
    );
  });

  it("should throw an error if required environment variables are missing", async () => {
    delete process.env.REACT_APP_RTOB_BASE_URL;

    const channelReference = "mocked_channel_ref";
    const file = new File(["dummy content"], "testDocument.pdf", {
      type: "application/pdf",
    });

    await expect(postDocuments(channelReference, file)).rejects.toThrow(
      "Missing required environment variables"
    );
  });

  it("should handle axios.post rejection and call dispatchError", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT =
      "/application-endpoint/";
    process.env.REACT_APP_RTOB_DOCUMENTS_END_POINT = "/documents-endpoint/";

    const mockedError = new Error("mocked_error");
    mockedAxios.post.mockRejectedValueOnce(mockedError);

    const channelReference = "mocked_channel_ref";
    const file = new File(["dummy content"], "testDocument.pdf", {
      type: "application/pdf",
    });

    await expect(postDocuments(channelReference, file)).rejects.toThrow(
      "mocked_error"
    );

    expect(dispatchError).toHaveBeenCalledWith(mockedError);
  });
});







import { render } from '@testing-library/react';
import { Provider } from 'react-redux';
import { createStore } from 'redux';
import FormComponent from './FormComponent'; // Assuming your form component
import * as redux from 'react-redux';

// Mocking the redux store and necessary hooks
jest.mock('react-redux', () => ({
  ...jest.requireActual('react-redux'),
  useDispatch: jest.fn(),
  useSelector: jest.fn(),
}));

// Create a mock store
const mockStore = createStore((state) => state, {
  // Initial mock state
  form: {
    applicants: [
      {
        HKID_a_1_final: 'A1234567',
        HKID_rp: 'B7654321',
      },
    ],
    application: {
      product_code: '001',
      application_status: 'Success',
      requested_loan_amount_a_1: '1000',
      premium_a_1: '200',
      currency_pl_a_1: 'USD',
    },
  },
  stages: {
    stages: [
      {
        stageId: 'AD_1',
      },
    ],
  },
  lovDesc: [
    {
      lov_code: '123',
      lov_value: 'Value1',
    },
    {
      lov_code: '456',
      lov_value: 'Value2',
    },
  ],
});

describe('FormComponent', () => {
  let store;

  beforeEach(() => {
    store = mockStore;
    // Mocking the redux state here as an example
    redux.useSelector.mockImplementation((selector) => selector(store.getState()));
    redux.useDispatch.mockReturnValue(jest.fn());
  });

  test('should build payload correctly for AD_1 stage', () => {
    const { container } = render(
      <Provider store={store}>
        <FormComponent />
      </Provider>
    );

    // Mock function to build the payload
    const buildPayload = () => {
      const state = store.getState();
      const { applicants, application, stages, lovDesc } = state.form;

      const payload = {
        applicants: applicants.map((applicant) => ({
          ...applicant,
          HKID_rp: applicant.HKID_rp || '',
        })),
        application,
        lov_desc: lovDesc.map((lov) => ({
          ...lov,
          description: `Description for ${lov.lov_value}`,
        })),
        stages: stages.stages.map((stage) => ({
          ...stage,
          stageId: stage.stageId,
        })),
      };

      // Return the payload object
      return payload;
    };

    // Run the payload construction function
    const payload = buildPayload();

    // Asserting that the payload is built correctly
    expect(payload.applicants[0].HKID_a_1_final).toBe('A1234567');
    expect(payload.applicants[0].HKID_rp).toBe('B7654321');
    expect(payload.application.product_code).toBe('001');
    expect(payload.application.requested_loan_amount_a_1).toBe('1000');
    expect(payload.application.premium_a_1).toBe('200');
    expect(payload.application.currency_pl_a_1).toBe('USD');
    expect(payload.stages[0].stageId).toBe('AD_1');
    expect(payload.lov_desc[0].description).toBe('Description for Value1');
    expect(payload.lov_desc[1].description).toBe('Description for Value2');
  });

  test('should handle empty applicants correctly', () => {
    const emptyStore = createStore((state) => state, {
      form: {
        applicants: [],
        application: {},
      },
    });

    redux.useSelector.mockImplementation((selector) => selector(emptyStore.getState()));

    const { container } = render(
      <Provider store={emptyStore}>
        <FormComponent />
      </Provider>
    );

    const payload = buildPayload();

    expect(payload.applicants).toEqual([]);
    expect(payload.application).toEqual({});
  });

  test('should update application status based on stage', () => {
    const updatedStore = createStore((state) => state, {
      form: {
        applicants: [
          {
            HKID_a_1_final: 'C1234567',
            HKID_rp: 'D7654321',
          },
        ],
        application: {
          product_code: '002',
          application_status: 'Pending',
          requested_loan_amount_a_1: '1500',
          premium_a_1: '250',
          currency_pl_a_1: 'EUR',
        },
      },
      stages: {
        stages: [
          {
            stageId: 'ACD_1',
          },
        ],
      },
    });

    redux.useSelector.mockImplementation((selector) => selector(updatedStore.getState()));

    const { container } = render(
      <Provider store={updatedStore}>
        <FormComponent />
      </Provider>
    );

    const payload = buildPayload();

    expect(payload.application.application_status).toBe('Pending');
    expect(payload.stages[0].stageId).toBe('ACD_1');
    expect(payload.application.requested_loan_amount_a_1).toBe('1500');
    expect(payload.application.currency_pl_a_1).toBe('EUR');
  });
});

