import React, {useState} from "react" ;
import { useSelector, useDispatch } from "react-redux";
import { dispatchLoader } from "../../../../../services/common-service";
import { StoreModel } from "../../../../../utils/model/common-model";
import { postDocuments,postZOLOCheck, postZolozAcknowledge,postPdfPreview } from "../../../services/preApprovalPostServices";
import { preApprovalAction } from "../../../store/preApproval-slice";
import Carousel from "../carousel/carousel";
import Modal from "../modals/tipsModal/tips-modal";
import banner1 from "../images-du/illustration-03@3x.png";
import banner2 from "../images-du/illustration-06@3x.png";
import banner3 from "../images-du/illustration-05@3x.png";
import banner4 from "../images-du/illustration-02@3x.png";
import banner5 from "../images-du/illustration-01@3x.png";
import banner6 from "../images-du/illustration-04@3x.png";
import { getImagePreview } from "../../../../preApproval/services/preApprovalServices";


const QRScreen : React.FC<any> =({showUploadFileSuccess, channel_reference, HKIDQRCodeData, HKIDVersionValue, setZolozDocumentData,setShowUploadFileSuccess,
  setDocumentData,
  showQRCodePage,
  setShowQRCodePage,
  setChangeIconColorIdentityProof,
  setShowIncomeProof,
  setDocumentCount,
  documentCount,
  setChangeIconIncomeProof,
  setSucsess,
  setShowContinueBtn,
  setHKIDVersion,

}) =>{
    const dispatch = useDispatch();
    const [isModalOpen, setIsModalOpen] = useState(false);
    const [imagePreview, setImagePreview] = useState(false);
    const [imgeURL, setImageURL] = useState("");
    const [name, setName] = useState("");
    const [validImageSizeModel, setValidImageSizeModel] = useState(false); 
    const [openSuccessModal, setOpenSuccessModal] = useState(false);
    const [continueBtnVisiblity, setContinueBtnVisiblity] = useState(false);



    const filesSelector = useSelector(
        (state: StoreModel) => state.preApproval.incomeProofDocumentUpload
      );
      const imgUrl = useSelector((state: any) => {
        return state?.preApproval?.imgPrevURL;
      });
      const docName = useSelector((state: any) => {
        return state?.preApproval?.documentZoloCheckRes?.data?.documents[0]
          ?.documentName;
      });
      const stageSelector = useSelector(
        (state: StoreModel) => state.stages.stages[0].stageInfo
      );
      const footeContent =
      "File format should be in JPG or PNG. The individual file size must not exceed 5MB. Click";
      const copyRights = "© Standard Chartered Bank (HK) Limited";

    const closeFileUpload = () => {
        // setShowIncomeProof("");
        // setShowQRCodePage(false);
        // setHKIDVersion("");
        // setShowContinueBtn(false);
      };

      const openImagePreview = (img: any, name: any) => {
        setImageURL(img);
        setName(name);
        setImagePreview(true);
      };

      const callModal = () => {
        setIsModalOpen(true);
      };
      const handleRefresh = (fileID: any, index: any) => { };
      const handleDelete = (docId: any) => {
        dispatch(preApprovalAction.setDeleteIncomeProofDocument(docId));
      };

      const handleUploadFile = async (e: any) => {
        const filename = e.target.files[0].name;
        const filesize = `${(e.target.files[0].size / (1024 * 1012)).toFixed(2)}MB`;
        const file = e.target.files[0];
        const maxSize = 5 * 1024 * 1024; //5MB in bytes
    
        if (file.size > maxSize) {
          setValidImageSizeModel(true);
    
          return;
        }
        try {
          await dispatch(dispatchLoader(true));
          const response = await postDocuments(
            channel_reference,
            e.target.files[0]
          );
          const tempData = {
            file: file,
            filename: filename,
            filesize: filesize,
            ...response.data,
          };
    
          if (response.statusText === "Accepted") {
            dispatch(preApprovalAction.setIncomeProofDocumentUpload(tempData));
          }
          await dispatch(dispatchLoader(false));
        } catch (err) {
          console.log("err:", err);
        }
      };

     const okBtnClick = (e: any) => {
    const { title } = e.target;

    if (title === "Colour Identity Proof") {
      setShowIncomeProof("");
      setDocumentCount(documentCount + 1);
      setShowQRCodePage(false);
      setChangeIconColorIdentityProof(false);
    } else if (title === "Income Proof") {
      setContinueBtnVisiblity(true);
      setDocumentCount(documentCount + 1);
      setShowIncomeProof("");
      // changeSuccessState(false);
      // setHKIDVersion("");
      setChangeIconIncomeProof(false);
      setSucsess(true);
    }
    setHKIDVersion("");
    setShowContinueBtn(false);
  };
      const images: any = [
        {
          banner: banner1,
          step: "Step 1",
          stepText: "Scan the QR code with a mobile phone",
        },
        {
          banner: banner2,
          step: "Step 2",
          stepText:
            "Remove card holder and place it on a flat surface under adequate lighting",
        },
        {
          banner: banner3,
          step: "Step 3",
          stepText:
            "Capture ID from above and align the edges with the rectangular frames",
        },
        {
          banner: banner4,
          step: "Step 4",
          stepText: "Tilt mobile phone about 30-degree and capture from aside",
        },
        {
          banner: banner5,
          step: "Step 5",
          stepText:
            "Remove accessories and face mask and place full face in the circular frame and blink once as instructed",
        },
        {
          banner: banner6,
          step: "Step 6",
          stepText: "Return to desktop browser and click “Submit” to continue",
        },
      ];
      const callSubmit = async () => {
        try {
          // setShowSpinner(true);
          dispatch(dispatchLoader(true));
          var transactionId = HKIDQRCodeData.transactionId;
          var docType = HKIDVersionValue;
          var document_type_code =
            stageSelector.applicant_documents[0]?.document_list[0]
              ?.document_options[0]?.document_types[0]?.document_type_code;
          const zoloCheckResponse = await postZOLOCheck(
            channel_reference,
            transactionId,
            docType
          );
          const documents = zoloCheckResponse?.data?.documents || [];
          const docId = documents[0]?.docId;
          setZolozDocumentData(documents[0]);
          const docFilter = documents.filter(
            (item: any) => item.document_type_code === document_type_code
          );
    
          //Update state with ZOLO check response
          dispatch(preApprovalAction.setDocumentZoloCheckRes(zoloCheckResponse));
    
          //Achnowledge the post
          const acknowledgeResponse = await postZolozAcknowledge(
            channel_reference,
            documents
          );
          const resStatus = acknowledgeResponse?.data?.[0]?.responseStatus;
    
          if (resStatus === "Success") {
            setOpenSuccessModal(true);
            setShowUploadFileSuccess(true);
    
            //Fetch and handle image preview
            const imagePreviewResponse = await getImagePreview(
              channel_reference,
              docId
            );
            const blob = imagePreviewResponse?.data;
            const imgObjURL = URL.createObjectURL(blob);
    
            dispatch(preApprovalAction.setImgPrevURL(imgObjURL));
            if (imagePreviewResponse.status === 200) {
              //PDF Preview
              const pdfPreviewRes = await postPdfPreview(channel_reference);
              if (pdfPreviewRes.status >= 200 && pdfPreviewRes.status < 300) {
                if (pdfPreviewRes.data.statusCode.toUpperCase() === "OK") {
                  setDocumentData(pdfPreviewRes.data.documents);
                  //   setShowSpinner(false);
                  dispatch(dispatchLoader(false));
                }
              } else {
                dispatch(dispatchLoader(false));
              }
            }
          }
        } catch (error) {
          console.log("error:", error);
        }
      };
   return(
     <>
            <div className="container">
              <div className="uploadHkDocument">
                <p className="doc-close" onClick={closeFileUpload}>
                  <span className="doc-close-btn"></span>
                  CLOSE
                </p>
                <p className="hk-proof-name">Colour Identity Proof</p>
              </div>
              <div className="qrMainLayOut">
                {!showUploadFileSuccess && (
                  <>
                    {" "}
                    <div className="qrCodeContent">
                      <div className="desktop-img">
                        <Carousel
                          image={images}
                          position={"absolute"}
                          top={"3em"}
                          left={"-4%"}
                          right={"55%"}
                          marginLeft={"20%"}
                          marginTop={"8%"}
                        />
                      </div>
                    </div>
                    <div className="qrImageSection">
                      <img
                        src={`data:image/png;base64,${HKIDQRCodeData?.qrCode}`}
                        alt="ORError"
                      />
                      <div className="qrSubmitButton">
                        <label
                          role="button"
                          title="submit-button"
                          className="upload-btn"
                          onClick={callSubmit}
                        >
                          <span className="upload-img"></span>
                          Submit
                        </label>
                      </div>
                    </div>
                  </>
                )}

                {
                  //onClick={()=>openImagePreview(item.imgurl, item.filename)}
                  showUploadFileSuccess && (
                    <>
                      <div className="upload-btn1" key={"index"}>
                        <div className="thumbnail-img-container">
                          <a>
                            <img
                              title="image-preview"
                              src={imgUrl}
                              onClick={() => openImagePreview(imgUrl, docName)}
                            ></img>
                          </a>
                        </div>
                        <div className="container-image">
                          <div className="uploading-doc-name">
                            <span className="span-file-name">{docName}</span>
                            <div className="progress-text-icon"></div>
                          </div>

                          <div
                            className={
                              "Upload completed" === "Upload completed"
                                ? // docStatus==="UPLOADED"
                                "uploaded"
                                : "retry-uploaded"
                            }
                          ></div>
                          <div
                            className={
                              "Upload completed" === "Upload completed"
                                ? "tick-mark"
                                : "no-tick-mark"
                            }
                          >
                            Upload completed
                          </div>
                        </div>
                      </div>
                    </>
                  )
                }
              </div>
              <div className="hk-copy-rights">
                <p>{copyRights}</p>
              </div>
            </div>
          </>
    
   )

}

export default QRScreen;








import React from "react";
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import { Provider } from "react-redux";
import configureStore from "redux-mock-store";
import QRScreen from "./QRScreen"; // Adjust the path accordingly
import { dispatchLoader } from "../../../../../services/common-service";
import { preApprovalAction } from "../../../store/preApproval-slice";

// Mock dependencies
jest.mock("../../../../../services/common-service", () => ({
  dispatchLoader: jest.fn(),
}));
jest.mock("../../../services/preApprovalPostServices", () => ({
  postDocuments: jest.fn(),
  postZOLOCheck: jest.fn(),
  postZolozAcknowledge: jest.fn(),
  postPdfPreview: jest.fn(),
}));
jest.mock("../../../../preApproval/services/preApprovalServices", () => ({
  getImagePreview: jest.fn(),
}));

// Mock assets
jest.mock("../images-du/illustration-03@3x.png", () => "mockImage1");
jest.mock("../images-du/illustration-06@3x.png", () => "mockImage2");

const mockStore = configureStore([]);

describe("QRScreen Component", () => {
  let store: any;

  const defaultProps = {
    showUploadFileSuccess: false,
    channel_reference: "test-channel",
    HKIDQRCodeData: { qrCode: "test-qr-code", transactionId: "test-tx-id" },
    HKIDVersionValue: "test-version",
    setZolozDocumentData: jest.fn(),
    setShowUploadFileSuccess: jest.fn(),
    setDocumentData: jest.fn(),
    setShowQRCodePage: jest.fn(),
    setChangeIconColorIdentityProof: jest.fn(),
    setShowIncomeProof: jest.fn(),
    setDocumentCount: jest.fn(),
    documentCount: 0,
    setChangeIconIncomeProof: jest.fn(),
    setSucsess: jest.fn(),
    setShowContinueBtn: jest.fn(),
    setHKIDVersion: jest.fn(),
  };

  beforeEach(() => {
    store = mockStore({
      preApproval: {
        incomeProofDocumentUpload: [],
        imgPrevURL: "mock-image-preview-url",
        documentZoloCheckRes: {
          data: {
            documents: [{ documentName: "Test Document" }],
          },
        },
      },
      stages: {
        stages: [
          {
            stageInfo: {
              applicant_documents: [
                {
                  document_list: [
                    {
                      document_options: [
                        {
                          document_types: [
                            { document_type_code: "test-doc-code" },
                          ],
                        },
                      ],
                    },
                  ],
                },
              ],
            },
          },
        ],
      },
    });
  });

  const renderComponent = () =>
    render(
      <Provider store={store}>
        <QRScreen {...defaultProps} />
      </Provider>
    );

  test("renders QRScreen with initial UI elements", () => {
    renderComponent();

    // Check if the main elements render
    expect(screen.getByText(/Colour Identity Proof/i)).toBeInTheDocument();
    expect(screen.getByText(/Scan the QR code/i)).toBeInTheDocument();
    expect(screen.getByAltText(/ORError/i)).toBeInTheDocument();
  });

  test("handles file upload and validates file size", async () => {
    const { postDocuments } = require("../../../services/preApprovalPostServices");

    renderComponent();

    const file = new File(["(⌐□_□)"], "test-image.png", { type: "image/png" });
    const input = screen.getByLabelText("Upload File");

    // Simulate file upload with valid size
    Object.defineProperty(input, "files", {
      value: [file],
    });

    fireEvent.change(input);

    await waitFor(() => {
      expect(dispatchLoader).toHaveBeenCalledWith(true);
      expect(postDocuments).toHaveBeenCalledWith(
        defaultProps.channel_reference,
        file
      );
    });
  });

  test("displays success modal after successful upload", async () => {
    const { postZOLOCheck, postZolozAcknowledge } = require("../../../services/preApprovalPostServices");
    const { getImagePreview } = require("../../../../preApproval/services/preApprovalServices");

    postZOLOCheck.mockResolvedValue({
      data: { documents: [{ docId: "test-doc-id" }] },
    });
    postZolozAcknowledge.mockResolvedValue({
      data: [{ responseStatus: "Success" }],
    });
    getImagePreview.mockResolvedValue({
      data: new Blob(),
      status: 200,
    });

    renderComponent();

    const submitButton = screen.getByTitle("submit-button");
    fireEvent.click(submitButton);

    await waitFor(() => {
      expect(postZOLOCheck).toHaveBeenCalled();
      expect(postZolozAcknowledge).toHaveBeenCalled();
      expect(defaultProps.setShowUploadFileSuccess).toHaveBeenCalledWith(true);
    });
  });

  test("handles image preview click", () => {
    renderComponent();

    // Simulate clicking the image for preview
    const previewImage = screen.getByTitle("image-preview");
    fireEvent.click(previewImage);

    expect(screen.getByText(/Test Document/i)).toBeInTheDocument();
  });

  test("handles closing the file upload section", () => {
    renderComponent();

    const closeButton = screen.getByText(/CLOSE/i);
    fireEvent.click(closeButton);

    expect(defaultProps.setShowQRCodePage).toHaveBeenCalledWith(false);
  });

  test("validates file size limit", async () => {
    renderComponent();

    const oversizedFile = new File(["a".repeat(6 * 1024 * 1024)], "oversize.png", {
      type: "image/png",
    });

    const input = screen.getByLabelText("Upload File");
    Object.defineProperty(input, "files", {
      value: [oversizedFile],
    });

    fireEvent.change(input);

    await waitFor(() => {
      expect(screen.getByText(/File size must not exceed 5MB/i)).toBeInTheDocument();
    });
  });
});








it('calls the callSubmit function and handles success response', async () => {
  // Mock successful API responses
  const mockZoloCheckResponse = {
    data: {
      documents: [
        {
          docId: 'doc123',
          document_type_code: 'TYPE001',
        },
      ],
    },
  };
  const mockAcknowledgeResponse = {
    data: [
      {
        responseStatus: 'Success',
      },
    ],
  };
  const mockPdfPreviewResponse = {
    status: 200,
    data: {
      statusCode: 'OK',
      documents: [],
    },
  };
  const mockImagePreviewBlob = new Blob(['mockImageData'], { type: 'image/png' });

  (preApprovalServices.postZOLOCheck as jest.Mock).mockResolvedValue(mockZoloCheckResponse);
  (preApprovalServices.postZolozAcknowledge as jest.Mock).mockResolvedValue(mockAcknowledgeResponse);
  (preApprovalServices.postPdfPreview as jest.Mock).mockResolvedValue(mockPdfPreviewResponse);
  (preApprovalServices.getImagePreview as jest.Mock).mockResolvedValue({
    data: mockImagePreviewBlob,
  });

  const { props } = setup();

  // Simulate clicking the submit button
  fireEvent.click(screen.getByRole('button', { name: /submit/i }));

  await waitFor(() => {
    // Ensure APIs are called in the correct order with expected arguments
    expect(preApprovalServices.postZOLOCheck).toHaveBeenCalledWith(
      mockChannelReference,
      mockHKIDQRCodeData.transactionId,
      'version1'
    );
    expect(preApprovalServices.postZolozAcknowledge).toHaveBeenCalledWith(
      mockChannelReference,
      mockZoloCheckResponse.data.documents
    );
    expect(preApprovalServices.getImagePreview).toHaveBeenCalledWith(
      mockChannelReference,
      'doc123'
    );
    expect(preApprovalServices.postPdfPreview).toHaveBeenCalledWith(mockChannelReference);

    // Ensure props functions are called to update state
    expect(props.setZolozDocumentData).toHaveBeenCalledWith(mockZoloCheckResponse.data.documents[0]);
    expect(props.setShowUploadFileSuccess).toHaveBeenCalledWith(true);
    expect(props.setDocumentData).toHaveBeenCalledWith(mockPdfPreviewResponse.data.documents);
  });
});

it('handles error in callSubmit gracefully', async () => {
  // Mock API responses with an error
  (preApprovalServices.postZOLOCheck as jest.Mock).mockRejectedValue(new Error('ZOLOCheck failed'));
  const { props } = setup();

  // Simulate clicking the submit button
  fireEvent.click(screen.getByRole('button', { name: /submit/i }));

  await waitFor(() => {
    // Ensure the ZOLO check API was called
    expect(preApprovalServices.postZOLOCheck).toHaveBeenCalledWith(
      mockChannelReference,
      mockHKIDQRCodeData.transactionId,
      'version1'
    );

    // Ensure the subsequent API calls are not made
    expect(preApprovalServices.postZolozAcknowledge).not.toHaveBeenCalled();
    expect(preApprovalServices.getImagePreview).not.toHaveBeenCalled();
    expect(preApprovalServices.postPdfPreview).not.toHaveBeenCalled();

    // No state updates should happen on failure
    expect(props.setZolozDocumentData).not.toHaveBeenCalled();
    expect(props.setShowUploadFileSuccess).not.toHaveBeenCalled();
    expect(props.setDocumentData).not.toHaveBeenCalled();
  });
});



















import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { Provider } from 'react-redux';
import configureStore from 'redux-mock-store';
import thunk from 'redux-thunk';
import QRScreen from './QRScreen';
import * as preApprovalServices from '../../../services/preApprovalPostServices';
import * as commonService from '../../../../../services/common-service';

// Mock Redux Store
const mockStore = configureStore([thunk]);
const initialState = {
  preApproval: {
    incomeProofDocumentUpload: [],
    imgPrevURL: '',
    documentZoloCheckRes: {
      data: {
        documents: [
          {
            documentName: 'SampleDoc.pdf',
          },
        ],
      },
    },
  },
  stages: {
    stages: [
      {
        stageInfo: {
          applicant_documents: [
            {
              document_list: [
                {
                  document_options: [
                    {
                      document_types: [{ document_type_code: 'TYPE001' }],
                    },
                  ],
                },
              ],
            },
          ],
        },
      },
    ],
  },
};

// Mock Props
const mockChannelReference = '12345';
const mockHKIDQRCodeData = { transactionId: 'trans123', qrCode: 'mockQRCodeBase64' };

// Mock APIs
jest.mock('../../../services/preApprovalPostServices', () => ({
  postDocuments: jest.fn(),
  postZOLOCheck: jest.fn(),
  postZolozAcknowledge: jest.fn(),
  postPdfPreview: jest.fn(),
  getImagePreview: jest.fn(),
}));
jest.mock('../../../../../services/common-service', () => ({
  dispatchLoader: jest.fn(),
}));

describe('QRScreen - callSubmit Function', () => {
  const setup = (propsOverride = {}) => {
    const props = {
      showUploadFileSuccess: false,
      channel_reference: mockChannelReference,
      HKIDQRCodeData: mockHKIDQRCodeData,
      HKIDVersionValue: 'version1',
      setZolozDocumentData: jest.fn(),
      setShowUploadFileSuccess: jest.fn(),
      setDocumentData: jest.fn(),
      setShowQRCodePage: jest.fn(),
      setChangeIconColorIdentityProof: jest.fn(),
      setShowIncomeProof: jest.fn(),
      setDocumentCount: jest.fn(),
      documentCount: 0,
      setChangeIconIncomeProof: jest.fn(),
      setSucsess: jest.fn(),
      setShowContinueBtn: jest.fn(),
      setHKIDVersion: jest.fn(),
      ...propsOverride,
    };

    const store = mockStore(initialState);

    return {
      ...render(
        <Provider store={store}>
          <QRScreen {...props} />
        </Provider>
      ),
      props,
      store,
    };
  };

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('handles success response for callSubmit', async () => {
    // Mock successful API responses
    const mockZoloCheckResponse = {
      data: {
        documents: [
          {
            docId: 'doc123',
            document_type_code: 'TYPE001',
          },
        ],
      },
    };
    const mockAcknowledgeResponse = {
      data: [
        {
          responseStatus: 'Success',
        },
      ],
    };
    const mockPdfPreviewResponse = {
      status: 200,
      data: {
        statusCode: 'OK',
        documents: [],
      },
    };
    const mockImagePreviewBlob = new Blob(['mockImageData'], { type: 'image/png' });

    (preApprovalServices.postZOLOCheck as jest.Mock).mockResolvedValue(mockZoloCheckResponse);
    (preApprovalServices.postZolozAcknowledge as jest.Mock).mockResolvedValue(mockAcknowledgeResponse);
    (preApprovalServices.postPdfPreview as jest.Mock).mockResolvedValue(mockPdfPreviewResponse);
    (preApprovalServices.getImagePreview as jest.Mock).mockResolvedValue({
      data: mockImagePreviewBlob,
    });

    const { props } = setup();

    // Simulate clicking the submit button
    fireEvent.click(screen.getByRole('button', { name: /submit/i }));

    await waitFor(() => {
      // Ensure APIs are called in the correct order with expected arguments
      expect(preApprovalServices.postZOLOCheck).toHaveBeenCalledWith(
        mockChannelReference,
        mockHKIDQRCodeData.transactionId,
        'version1'
      );
      expect(preApprovalServices.postZolozAcknowledge).toHaveBeenCalledWith(
        mockChannelReference,
        mockZoloCheckResponse.data.documents
      );
      expect(preApprovalServices.getImagePreview).toHaveBeenCalledWith(
        mockChannelReference,
        'doc123'
      );
      expect(preApprovalServices.postPdfPreview).toHaveBeenCalledWith(mockChannelReference);

      // Ensure props functions are called to update state
      expect(props.setZolozDocumentData).toHaveBeenCalledWith(mockZoloCheckResponse.data.documents[0]);
      expect(props.setShowUploadFileSuccess).toHaveBeenCalledWith(true);
      expect(props.setDocumentData).toHaveBeenCalledWith(mockPdfPreviewResponse.data.documents);
    });
  });

  it('handles error response for callSubmit', async () => {
    // Mock API responses with an error
    (preApprovalServices.postZOLOCheck as jest.Mock).mockRejectedValue(new Error('ZOLOCheck failed'));

    const { props } = setup();

    // Simulate clicking the submit button
    fireEvent.click(screen.getByRole('button', { name: /submit/i }));

    await waitFor(() => {
      // Ensure the ZOLO check API was called
      expect(preApprovalServices.postZOLOCheck).toHaveBeenCalledWith(
        mockChannelReference,
        mockHKIDQRCodeData.transactionId,
        'version1'
      );

      // Ensure the subsequent API calls are not made
      expect(preApprovalServices.postZolozAcknowledge).not.toHaveBeenCalled();
      expect(preApprovalServices.getImagePreview).not.toHaveBeenCalled();
      expect(preApprovalServices.postPdfPreview).not.toHaveBeenCalled();

      // No state updates should happen on failure
      expect(props.setZolozDocumentData).not.toHaveBeenCalled();
      expect(props.setShowUploadFileSuccess).not.toHaveBeenCalled();
      expect(props.setDocumentData).not.toHaveBeenCalled();
    });
  });
});




import { callSubmit } from './path_to_callSubmit'; // Adjust the import path
import {
  postZOLOCheck,
  postZolozAcknowledge,
  getImagePreview,
  postPdfPreview,
} from './api'; // Mock these functions
import { dispatchLoader, preApprovalAction } from './actions'; // Mock Redux actions

jest.mock('./api');
jest.mock('./actions', () => ({
  dispatchLoader: jest.fn(),
  preApprovalAction: {
    setDocumentZoloCheckRes: jest.fn(),
    setImgPrevURL: jest.fn(),
  },
}));

const dispatch = jest.fn();
const setZolozDocumentData = jest.fn();
const setOpenSuccessModal = jest.fn();
const setShowUploadFileSuccess = jest.fn();
const setDocumentData = jest.fn();

describe('callSubmit', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should successfully complete the flow with valid data', async () => {
    // Mock API responses
    const mockZoloCheckResponse = {
      data: {
        documents: [
          { docId: 'doc123', document_type_code: 'HKID' },
        ],
      },
    };
    const mockAcknowledgeResponse = {
      data: [{ responseStatus: 'Success' }],
    };
    const mockImagePreviewResponse = {
      data: new Blob(),
      status: 200,
    };
    const mockPdfPreviewResponse = {
      data: {
        statusCode: 'OK',
        documents: [{ id: 'doc456', name: 'Sample Doc' }],
      },
      status: 200,
    };

    // Mock API functions
    postZOLOCheck.mockResolvedValue(mockZoloCheckResponse);
    postZolozAcknowledge.mockResolvedValue(mockAcknowledgeResponse);
    getImagePreview.mockResolvedValue(mockImagePreviewResponse);
    postPdfPreview.mockResolvedValue(mockPdfPreviewResponse);

    // Mock global variables
    const channel_reference = 'channel123';
    const HKIDQRCodeData = { transactionId: 'txn123' };
    const HKIDVersionValue = 'version1';
    const stageSelector = {
      applicant_documents: [
        {
          document_list: [
            {
              document_options: [
                {
                  document_types: [
                    { document_type_code: 'HKID' },
                  ],
                },
              ],
            },
          ],
        },
      ],
    };

    // Call the function
    await callSubmit({
      dispatch,
      HKIDQRCodeData,
      HKIDVersionValue,
      stageSelector,
      setZolozDocumentData,
      setOpenSuccessModal,
      setShowUploadFileSuccess,
      setDocumentData,
    });

    // Assertions for API calls
    expect(postZOLOCheck).toHaveBeenCalledWith('channel123', 'txn123', 'version1');
    expect(postZolozAcknowledge).toHaveBeenCalledWith('channel123', mockZoloCheckResponse.data.documents);
    expect(getImagePreview).toHaveBeenCalledWith('channel123', 'doc123');
    expect(postPdfPreview).toHaveBeenCalledWith('channel123');

    // Assertions for state updates
    expect(dispatch).toHaveBeenCalledWith(dispatchLoader(true));
    expect(dispatch).toHaveBeenCalledWith(preApprovalAction.setDocumentZoloCheckRes(mockZoloCheckResponse));
    expect(setZolozDocumentData).toHaveBeenCalledWith(mockZoloCheckResponse.data.documents[0]);
    expect(setOpenSuccessModal).toHaveBeenCalledWith(true);
    expect(setShowUploadFileSuccess).toHaveBeenCalledWith(true);
    expect(dispatch).toHaveBeenCalledWith(preApprovalAction.setImgPrevURL(expect.any(String)));
    expect(setDocumentData).toHaveBeenCalledWith(mockPdfPreviewResponse.data.documents);

    // Ensure spinner is hidden at the end
    expect(dispatch).toHaveBeenCalledWith(dispatchLoader(false));
  });

  it('should handle API errors gracefully', async () => {
    // Mock API functions to throw an error
    postZOLOCheck.mockRejectedValue(new Error('Network Error'));

    // Call the function
    await callSubmit({
      dispatch,
      HKIDQRCodeData: { transactionId: 'txn123' },
      HKIDVersionValue: 'version1',
      stageSelector: {
        applicant_documents: [
          {
            document_list: [
              {
                document_options: [
                  {
                    document_types: [
                      { document_type_code: 'HKID' },
                    ],
                  },
                ],
              },
            ],
          },
        ],
      },
      setZolozDocumentData,
      setOpenSuccessModal,
      setShowUploadFileSuccess,
      setDocumentData,
    });

    // Assertions
    expect(postZOLOCheck).toHaveBeenCalledTimes(1);
    expect(dispatch).toHaveBeenCalledWith(dispatchLoader(true));
    expect(dispatch).toHaveBeenCalledWith(dispatchLoader(false));
    expect(console.log).toHaveBeenCalledWith('error:', expect.any(Error));
  });

  it('should handle an unsuccessful acknowledgment response', async () => {
    // Mock API responses
    const mockZoloCheckResponse = {
      data: {
        documents: [
          { docId: 'doc123', document_type_code: 'HKID' },
        ],
      },
    };
    const mockAcknowledgeResponse = {
      data: [{ responseStatus: 'Failed' }],
    };

    postZOLOCheck.mockResolvedValue(mockZoloCheckResponse);
    postZolozAcknowledge.mockResolvedValue(mockAcknowledgeResponse);

    // Call the function
    await callSubmit({
      dispatch,
      HKIDQRCodeData: { transactionId: 'txn123' },
      HKIDVersionValue: 'version1',
      stageSelector: {
        applicant_documents: [
          {
            document_list: [
              {
                document_options: [
                  {
                    document_types: [
                      { document_type_code: 'HKID' },
                    ],
                  },
                ],
              },
            ],
          },
        ],
      },
      setZolozDocumentData,
      setOpenSuccessModal,
      setShowUploadFileSuccess,
      setDocumentData,
    });

    // Assertions
    expect(setOpenSuccessModal).not.toHaveBeenCalled();
    expect(setShowUploadFileSuccess).not.toHaveBeenCalled();
  });
});










import React from 'react';
import { render, fireEvent, screen } from '@testing-library/react';
import { QRScreen } from './QRScreen';
import {
  postZOLOCheck,
  postZolozAcknowledge,
  getImagePreview,
  postPdfPreview,
} from './api';
import { dispatchLoader, preApprovalAction } from './actions';

jest.mock('./api');
jest.mock('./actions', () => ({
  dispatchLoader: jest.fn(),
  preApprovalAction: {
    setImgPrevURL: jest.fn(),
  },
}));

const mockDispatch = jest.fn();
jest.mock('react-redux', () => ({
  useDispatch: () => mockDispatch,
}));

describe('QRScreen Component', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should handle successful API call flow', async () => {
    // Mock API responses
    postZOLOCheck.mockResolvedValue({
      data: {
        documents: [{ docId: 'doc123', document_type_code: 'HKID' }],
      },
    });
    postZolozAcknowledge.mockResolvedValue({
      data: [{ responseStatus: 'Success' }],
    });
    getImagePreview.mockResolvedValue({
      data: new Blob(),
      status: 200,
    });
    postPdfPreview.mockResolvedValue({
      data: { statusCode: 'OK', documents: [{ id: 'doc456', name: 'Sample Doc' }] },
      status: 200,
    });

    // Render the component
    render(<QRScreen />);

    // Trigger callSubmit
    fireEvent.click(screen.getByText('Submit'));

    // Wait for success modal to appear
    await screen.findByText('Success Modal Opened');

    // Assertions
    expect(postZOLOCheck).toHaveBeenCalledWith('channel123', 'txn123', 'version1');
    expect(postZolozAcknowledge).toHaveBeenCalledTimes(1);
    expect(getImagePreview).toHaveBeenCalledTimes(1);
    expect(postPdfPreview).toHaveBeenCalledTimes(1);

    // Check dispatch calls
    expect(mockDispatch).toHaveBeenCalledWith(dispatchLoader(true));
    expect(mockDispatch).toHaveBeenCalledWith(dispatchLoader(false));
    expect(preApprovalAction.setImgPrevURL).toHaveBeenCalledWith(expect.any(String));
  });

  it('should handle API errors gracefully', async () => {
    // Mock API failure
    postZOLOCheck.mockRejectedValue(new Error('Network Error'));

    // Render the component
    render(<QRScreen />);

    // Trigger callSubmit
    fireEvent.click(screen.getByText('Submit'));

    // Wait for error handling to complete
    await screen.findByText('Submit'); // Ensure no modal appears

    // Assertions
    expect(postZOLOCheck).toHaveBeenCalledTimes(1);
    expect(mockDispatch).toHaveBeenCalledWith(dispatchLoader(true));
    expect(mockDispatch).toHaveBeenCalledWith(dispatchLoader(false));
  });

  it('should handle unsuccessful acknowledgment response', async () => {
    // Mock API responses
    postZOLOCheck.mockResolvedValue({
      data: {
        documents: [{ docId: 'doc123', document_type_code: 'HKID' }],
      },
    });
    postZolozAcknowledge.mockResolvedValue({
      data: [{ responseStatus: 'Failed' }],
    });

    // Render the component
    render(<QRScreen />);

    // Trigger callSubmit
    fireEvent.click(screen.getByText('Submit'));

    // Wait for acknowledgment handling
    await screen.findByText('Submit'); // Ensure no modal appears

    // Assertions
    expect(postZOLOCheck).toHaveBeenCalledTimes(1);
    expect(postZolozAcknowledge).toHaveBeenCalledTimes(1);
    expect(mockDispatch).toHaveBeenCalledWith(dispatchLoader(true));
    expect(mockDispatch).toHaveBeenCalledWith(dispatchLoader(false));
  });
});
