test("should call getOffer2 and resolve with response", async () => {
  // Mock the state
  jest.spyOn(store, "getState").mockReturnValue({
    stages: {
      stages: [
        {
          stageId: "mockStageId",
          stageInfo: {
            application: {
              channel_reference: "mockChannelRef",
            },
            products: [
              {
                product_type: "mockProductType",
              },
            ],
          },
        },
      ],
    },
  });

  const mockPayload = { someKey: "someValue" };
  const mockResponse = { data: { offerDetails: "mockOfferDetails" }, status: 200 };

  mockedAxios.post.mockResolvedValue(mockResponse);

  const result = await getOffer2(mockPayload);

  // Assertions
  expect(result).toEqual(mockResponse);
  expect(mockedAxios.post).toHaveBeenCalledWith(
    expect.stringContaining("mockChannelRef"), // Ensure the correct endpoint is used
    JSON.stringify({
      ...mockPayload,
      stage: {
        page_id: "mockStageId",
        stage_id: "MOCKSTAGEID",
        stage_status: "incomplete",
      },
      applicants: expect.any(Object), // Ensure applicants field is present
      client: expect.any(Object), // Ensure client field is present
    }),
    expect.objectContaining({
      headers: expect.objectContaining({
        "Content-Type": "application/json;charset=UTF-8",
      }),
    })
  );
});

test("should handle error in getOffer2", async () => {
  // Mock the state
  jest.spyOn(store, "getState").mockReturnValue({
    stages: {
      stages: [
        {
          stageId: "mockStageId",
          stageInfo: {
            application: {
              channel_reference: "mockChannelRef",
            },
          },
        },
      ],
    },
  });

  const mockPayload = { someKey: "someValue" };
  const mockError = new Error("Offer2 API error");

  mockedAxios.post.mockRejectedValue(mockError);

  await expect(getOffer2(mockPayload)).rejects.toThrow("Offer2 API error");

  // Ensure dispatchError is called
  expect(commonService.dispatchError).toHaveBeenCalledWith(mockError);
});


test("should call getOfferCalulated and resolve with response", async () => {
  // Mock the state
  jest.spyOn(store, "getState").mockReturnValue({
    stages: {
      stages: [
        {
          stageInfo: {
            application: {
              channel_reference: "mockChannelRef",
              cos_ref_number: "mockCosRef",
              application_reference: "mockAppRef",
            },
          },
        },
      ],
    },
  });

  const mockData = {
    requested_amount: 10000,
    requested_tenure: 12,
  };
  const mockResponse = { data: { calculatedOffer: "mockCalculatedOffer" }, status: 200 };

  mockedAxios.post.mockResolvedValue(mockResponse);

  const result = await getOfferCalulated(mockData);

  // Assertions
  expect(result).toEqual(mockResponse);
  expect(mockedAxios.post).toHaveBeenCalledWith(
    expect.stringContaining("mockChannelRef"), // Ensure the correct endpoint is used
    JSON.stringify({
      channel_ref_number: "mockChannelRef",
      cos_ref_number: "mockCosRef",
      application_reference: "mockAppRef",
      source_system_name: "02",
      requested_amount: 10000,
      requested_tenure: 12,
    }),
    expect.objectContaining({
      headers: expect.objectContaining({
        "Content-Type": "application/json;charset=UTF-8",
      }),
    })
  );
});



test("should handle error in getOfferCalulated", async () => {
  // Mock the state
  jest.spyOn(store, "getState").mockReturnValue({
    stages: {
      stages: [
        {
          stageInfo: {
            application: {
              channel_reference: "mockChannelRef",
              cos_ref_number: "mockCosRef",
              application_reference: "mockAppRef",
            },
          },
        },
      ],
    },
  });

  const mockData = {
    requested_amount: 10000,
    requested_tenure: 12,
  };
  const mockError = new Error("OfferCalulated API error");

  mockedAxios.post.mockRejectedValue(mockError);

  await expect(getOfferCalulated(mockData)).rejects.toThrow("OfferCalulated API error");

  // Ensure dispatchError is called
  expect(commonService.dispatchError).toHaveBeenCalledWith(mockError);
});



import { postBasicData } from "./yourFile";
import axios from "axios";
import { store } from "../../../utils/store/store";
import PreApprovalUtil from "./preApprovalUtils";
import { dispatchError } from "../../../services/common-service";

jest.mock("axios"); // Mock axios globally
jest.mock("../../../utils/store/store", () => ({
  store: {
    getState: jest.fn(),
  },
}));
jest.mock("./preApprovalUtils", () => ({
  getFormConfigPayload: jest.fn(),
  getAckMetaData: jest.fn(),
}));
jest.mock("../../../services/common-service", () => ({
  dispatchError: jest.fn(),
}));

const mockedAxios = axios as jest.Mocked<typeof axios>;

describe("postBasicData", () => {
  beforeEach(() => {
    mockedAxios.post.mockReset();
    (store.getState as jest.Mock).mockReturnValue({
      stages: {
        stages: [
          {
            stageInfo: {
              application: {
                channel_reference: "mocked_channel_ref",
              },
            },
          },
        ],
      },
    });

    PreApprovalUtil.getFormConfigPayload.mockReturnValue({
      applicants: {},
      application: {},
    });

    PreApprovalUtil.getAckMetaData.mockReturnValue("mocked_ack_meta_data");
  });

  it("should call axios.post with correct arguments and resolve", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_BASIC_DATA_END_POINT = "/basic-data-endpoint/";

    const mockedResponse = { data: "mocked_response" };
    mockedAxios.post.mockResolvedValueOnce(mockedResponse);

    const result = await postBasicData();

    const expectedUrl =
      "https://mock-base-url/application-endpoint/mocked_channel_ref/basic-data-endpoint/";
    const expectedHeaders = {
      "Content-Type": "application/json;charset=UTF-8",
      "Sc-Client-Context": "mocked_ack_meta_data",
    };
    const expectedPayload = JSON.stringify({
      applicants: {},
      application: {},
    });

    expect(mockedAxios.post).toHaveBeenCalledWith(expectedUrl, expectedPayload, {
      headers: expectedHeaders,
    });
    expect(result).toEqual(mockedResponse);
  });

  it("should handle axios.post rejection and call dispatchError", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_BASIC_DATA_END_POINT = "/basic-data-endpoint/";

    const mockedError = new Error("mocked_error");
    mockedAxios.post.mockRejectedValueOnce(mockedError);

    await expect(postBasicData()).rejects.toThrow("mocked_error");

    expect(dispatchError).toHaveBeenCalledWith(mockedError);
  });
});
