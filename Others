test("should call getOffer2 and resolve with response", async () => {
  // Mock the state
  jest.spyOn(store, "getState").mockReturnValue({
    stages: {
      stages: [
        {
          stageId: "mockStageId",
          stageInfo: {
            application: {
              channel_reference: "mockChannelRef",
            },
            products: [
              {
                product_type: "mockProductType",
              },
            ],
          },
        },
      ],
    },
  });

  const mockPayload = { someKey: "someValue" };
  const mockResponse = { data: { offerDetails: "mockOfferDetails" }, status: 200 };

  mockedAxios.post.mockResolvedValue(mockResponse);

  const result = await getOffer2(mockPayload);

  // Assertions
  expect(result).toEqual(mockResponse);
  expect(mockedAxios.post).toHaveBeenCalledWith(
    expect.stringContaining("mockChannelRef"), // Ensure the correct endpoint is used
    JSON.stringify({
      ...mockPayload,
      stage: {
        page_id: "mockStageId",
        stage_id: "MOCKSTAGEID",
        stage_status: "incomplete",
      },
      applicants: expect.any(Object), // Ensure applicants field is present
      client: expect.any(Object), // Ensure client field is present
    }),
    expect.objectContaining({
      headers: expect.objectContaining({
        "Content-Type": "application/json;charset=UTF-8",
      }),
    })
  );
});

test("should handle error in getOffer2", async () => {
  // Mock the state
  jest.spyOn(store, "getState").mockReturnValue({
    stages: {
      stages: [
        {
          stageId: "mockStageId",
          stageInfo: {
            application: {
              channel_reference: "mockChannelRef",
            },
          },
        },
      ],
    },
  });

  const mockPayload = { someKey: "someValue" };
  const mockError = new Error("Offer2 API error");

  mockedAxios.post.mockRejectedValue(mockError);

  await expect(getOffer2(mockPayload)).rejects.toThrow("Offer2 API error");

  // Ensure dispatchError is called
  expect(commonService.dispatchError).toHaveBeenCalledWith(mockError);
});


test("should call getOfferCalulated and resolve with response", async () => {
  // Mock the state
  jest.spyOn(store, "getState").mockReturnValue({
    stages: {
      stages: [
        {
          stageInfo: {
            application: {
              channel_reference: "mockChannelRef",
              cos_ref_number: "mockCosRef",
              application_reference: "mockAppRef",
            },
          },
        },
      ],
    },
  });

  const mockData = {
    requested_amount: 10000,
    requested_tenure: 12,
  };
  const mockResponse = { data: { calculatedOffer: "mockCalculatedOffer" }, status: 200 };

  mockedAxios.post.mockResolvedValue(mockResponse);

  const result = await getOfferCalulated(mockData);

  // Assertions
  expect(result).toEqual(mockResponse);
  expect(mockedAxios.post).toHaveBeenCalledWith(
    expect.stringContaining("mockChannelRef"), // Ensure the correct endpoint is used
    JSON.stringify({
      channel_ref_number: "mockChannelRef",
      cos_ref_number: "mockCosRef",
      application_reference: "mockAppRef",
      source_system_name: "02",
      requested_amount: 10000,
      requested_tenure: 12,
    }),
    expect.objectContaining({
      headers: expect.objectContaining({
        "Content-Type": "application/json;charset=UTF-8",
      }),
    })
  );
});



test("should handle error in getOfferCalulated", async () => {
  // Mock the state
  jest.spyOn(store, "getState").mockReturnValue({
    stages: {
      stages: [
        {
          stageInfo: {
            application: {
              channel_reference: "mockChannelRef",
              cos_ref_number: "mockCosRef",
              application_reference: "mockAppRef",
            },
          },
        },
      ],
    },
  });

  const mockData = {
    requested_amount: 10000,
    requested_tenure: 12,
  };
  const mockError = new Error("OfferCalulated API error");

  mockedAxios.post.mockRejectedValue(mockError);

  await expect(getOfferCalulated(mockData)).rejects.toThrow("OfferCalulated API error");

  // Ensure dispatchError is called
  expect(commonService.dispatchError).toHaveBeenCalledWith(mockError);
});



import { postBasicData } from "./yourFile";
import axios from "axios";
import { store } from "../../../utils/store/store";
import PreApprovalUtil from "./preApprovalUtils";
import { dispatchError } from "../../../services/common-service";

jest.mock("axios"); // Mock axios globally
jest.mock("../../../utils/store/store", () => ({
  store: {
    getState: jest.fn(),
  },
}));
jest.mock("./preApprovalUtils", () => ({
  getFormConfigPayload: jest.fn(),
  getAckMetaData: jest.fn(),
}));
jest.mock("../../../services/common-service", () => ({
  dispatchError: jest.fn(),
}));

const mockedAxios = axios as jest.Mocked<typeof axios>;

describe("postBasicData", () => {
  beforeEach(() => {
    mockedAxios.post.mockReset();
    (store.getState as jest.Mock).mockReturnValue({
      stages: {
        stages: [
          {
            stageInfo: {
              application: {
                channel_reference: "mocked_channel_ref",
              },
            },
          },
        ],
      },
    });

    PreApprovalUtil.getFormConfigPayload.mockReturnValue({
      applicants: {},
      application: {},
    });

    PreApprovalUtil.getAckMetaData.mockReturnValue("mocked_ack_meta_data");
  });

  it("should call axios.post with correct arguments and resolve", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_BASIC_DATA_END_POINT = "/basic-data-endpoint/";

    const mockedResponse = { data: "mocked_response" };
    mockedAxios.post.mockResolvedValueOnce(mockedResponse);

    const result = await postBasicData();

    const expectedUrl =
      "https://mock-base-url/application-endpoint/mocked_channel_ref/basic-data-endpoint/";
    const expectedHeaders = {
      "Content-Type": "application/json;charset=UTF-8",
      "Sc-Client-Context": "mocked_ack_meta_data",
    };
    const expectedPayload = JSON.stringify({
      applicants: {},
      application: {},
    });

    expect(mockedAxios.post).toHaveBeenCalledWith(expectedUrl, expectedPayload, {
      headers: expectedHeaders,
    });
    expect(result).toEqual(mockedResponse);
  });

  it("should handle axios.post rejection and call dispatchError", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_BASIC_DATA_END_POINT = "/basic-data-endpoint/";

    const mockedError = new Error("mocked_error");
    mockedAxios.post.mockRejectedValueOnce(mockedError);

    await expect(postBasicData()).rejects.toThrow("mocked_error");

    expect(dispatchError).toHaveBeenCalledWith(mockedError);
  });
});

import { postZOLOCheck } from "./yourFile";
import axios from "axios";
import { store } from "../../../utils/store/store";
import PreApprovalUtil from "./preApprovalUtils";
import { dispatchError } from "../../../services/common-service";

jest.mock("axios");
jest.mock("../../../utils/store/store", () => ({
  store: {
    getState: jest.fn(),
  },
}));
jest.mock("./preApprovalUtils", () => ({
  getAckMetaData: jest.fn(),
}));
jest.mock("../../../services/common-service", () => ({
  dispatchError: jest.fn(),
}));

const mockedAxios = axios as jest.Mocked<typeof axios>;

describe("postZOLOCheck", () => {
  beforeEach(() => {
    mockedAxios.post.mockReset();
    (store.getState as jest.Mock).mockReturnValue({
      stages: {
        stages: [
          {
            stageInfo: {
              applicants: {
                first_name_a_1: "John",
                last_name_a_1: "Doe",
                date_of_birth_a_1: "1990-01-01",
                HKID_a_1: "A1234567",
                product_type: "CreditCard",
                product_category: "Platinum",
              },
              application: {
                cos_ref_number: "COS123456",
              },
            },
          },
        ],
      },
    });

    PreApprovalUtil.getAckMetaData.mockReturnValue("mocked_ack_meta_data");
  });

  it("should call axios.post with correct arguments and resolve", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_ZOLO_CHECK_RESULT_END_POINT = "/zolo-check-endpoint/";

    const mockedResponse = { data: "mocked_response" };
    mockedAxios.post.mockResolvedValueOnce(mockedResponse);

    const channelReference = "mocked_channel_ref";
    const transactionId = "txn123456";
    const docType = "HKID";

    const result = await postZOLOCheck(channelReference, transactionId, docType);

    const expectedUrl = "https://mock-base-url/application-endpoint/mocked_channel_ref/zolo-check-endpoint/";
    const expectedPayload = {
      transactionId: "txn123456",
      isReturnImage: "Y",
      first_name_a_1: "John",
      last_name_a_1: "Doe",
      date_of_birth_a_1: "1990-01-01",
      HKID_a_1: "A1234567",
      product_type: "CreditCard",
      product_category: "Platinum",
      hkid_type: "HKID",
      cos_ref_number: "COS123456",
    };
    const expectedHeaders = {
      "Content-Type": "application/json;charset=UTF-8",
      "Sc-Client-Context": "mocked_ack_meta_data",
    };

    expect(mockedAxios.post).toHaveBeenCalledWith(expectedUrl, JSON.stringify(expectedPayload), {
      headers: expectedHeaders,
    });
    expect(result).toEqual(mockedResponse);
  });

  it("should handle axios.post rejection and call dispatchError", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_ZOLO_CHECK_RESULT_END_POINT = "/zolo-check-endpoint/";

    const mockedError = new Error("mocked_error");
    mockedAxios.post.mockRejectedValueOnce(mockedError);

    const channelReference = "mocked_channel_ref";
    const transactionId = "txn123456";
    const docType = "HKID";

    await expect(postZOLOCheck(channelReference, transactionId, docType)).rejects.toThrow(
      "mocked_error"
    );

    expect(dispatchError).toHaveBeenCalledWith(mockedError);
  });
});


import { postZoloAcknowledge } from "./yourFile";
import axios from "axios";
import { store } from "../../../utils/store/store";
import PreApprovalUtil from "./preApprovalUtils";
import { dispatchError } from "../../../services/common-service";

jest.mock("axios");
jest.mock("../../../utils/store/store", () => ({
  store: {
    getState: jest.fn(),
  },
}));
jest.mock("./preApprovalUtils", () => ({
  getAckMetaData: jest.fn(),
}));
jest.mock("../../../services/common-service", () => ({
  dispatchError: jest.fn(),
}));

const mockedAxios = axios as jest.Mocked<typeof axios>;

describe("postZoloAcknowledge", () => {
  beforeEach(() => {
    mockedAxios.post.mockReset();
    (store.getState as jest.Mock).mockReturnValue({
      stages: {
        stages: [
          {
            stageInfo: {
              application: {
                channel_reference: "mocked_channel_ref",
                application_reference: "mocked_application_ref",
              },
            },
          },
        ],
      },
    });

    PreApprovalUtil.getAckMetaData.mockReturnValue("mocked_ack_meta_data");
  });

  it("should call axios.post with correct arguments and resolve", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_DOCUMENTS_END_POINT = "/documents-endpoint/";
    process.env.REACT_APP_RTOB_ACKNOWLEDGE_END_POINT = "/acknowledge-endpoint/";

    const mockedResponse = { data: "mocked_response" };
    mockedAxios.post.mockResolvedValueOnce(mockedResponse);

    const channelReference = "mocked_channel_ref";
    const documentsList = [
      {
        docId: "doc123",
        documentName: "testDocument.pdf",
        documentStatus: "Accepted",
      },
    ];

    const result = await postZoloAcknowledge(channelReference, documentsList);

    const expectedUrl =
      "https://mock-base-url/application-endpoint/mocked_channel_ref/documents-endpoint/acknowledge-endpoint/";
    const expectedPayload = {
      applicationRefNo: "mocked_application_ref",
      documents: documentsList,
      optionsSelected: [
        {
          applicantId: 1,
          options: [
            {
              documentCategoryCode: "R0001",
              documentTypeCode: "A001",
              documentOptionSequence: "1",
            },
          ],
        },
      ],
      stage: "Zoloz_ACK",
    };
    const expectedHeaders = {
      "Content-Type": "application/json;charset=UTF-8",
      "Sc-Client-Context": "mocked_ack_meta_data",
    };

    expect(mockedAxios.post).toHaveBeenCalledWith(expectedUrl, JSON.stringify(expectedPayload), {
      headers: expectedHeaders,
    });
    expect(result).toEqual(mockedResponse);
  });

  it("should handle axios.post rejection and call dispatchError", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_DOCUMENTS_END_POINT = "/documents-endpoint/";
    process.env.REACT_APP_RTOB_ACKNOWLEDGE_END_POINT = "/acknowledge-endpoint/";

    const mockedError = new Error("mocked_error");
    mockedAxios.post.mockRejectedValueOnce(mockedError);

    const channelReference = "mocked_channel_ref";
    const documentsList = [
      {
        docId: "doc123",
        documentName: "testDocument.pdf",
        documentStatus: "Accepted",
      },
    ];

    await expect(postZoloAcknowledge(channelReference, documentsList)).rejects.toThrow(
      "mocked_error"
    );

    expect(dispatchError).toHaveBeenCalledWith(mockedError);
  });
});

import { postFinalAcknowledge } from "./yourFile";
import axios from "axios";
import { store } from "../../../utils/store/store";
import PreApprovalUtil from "./preApprovalUtils";
import { dispatchError } from "../../../services/common-service";

jest.mock("axios");
jest.mock("../../../utils/store/store", () => ({
  store: {
    getState: jest.fn(),
  },
}));
jest.mock("./preApprovalUtils", () => ({
  getAckMetaData: jest.fn(),
}));
jest.mock("../../../services/common-service", () => ({
  dispatchError: jest.fn(),
}));

const mockedAxios = axios as jest.Mocked<typeof axios>;

describe("postFinalAcknowledge", () => {
  beforeEach(() => {
    mockedAxios.post.mockReset();
    (store.getState as jest.Mock).mockReturnValue({
      stages: {
        stages: [
          {
            stageInfo: {
              application: {
                channel_reference: "mocked_channel_ref",
                application_reference: "mocked_application_ref",
              },
            },
          },
        ],
      },
    });

    PreApprovalUtil.getAckMetaData.mockReturnValue("mocked_ack_meta_data");
  });

  it("should call axios.post with correct arguments and resolve", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_DOCUMENTS_END_POINT = "/documents-endpoint/";
    process.env.REACT_APP_RTOB_ACKNOWLEDGE_END_POINT = "/acknowledge-endpoint/";

    const mockedResponse = { data: "mocked_response" };
    mockedAxios.post.mockResolvedValueOnce(mockedResponse);

    const channelReference = "mocked_channel_ref";

    const result = await postFinalAcknowledge(channelReference);

    const expectedUrl =
      "https://mock-base-url/application-endpoint/mocked_channel_ref/documents-endpoint/acknowledge-endpoint/";
    const expectedPayload = {
      applicationRefNo: "mocked_application_ref",
      documents: [],
      optionsSelected: [
        {
          applicantId: 1,
          options: [],
        },
      ],
      stage: "Final_ACK",
    };
    const expectedHeaders = {
      "Content-Type": "application/json;charset=UTF-8",
      "Sc-Client-Context": "mocked_ack_meta_data",
    };

    expect(mockedAxios.post).toHaveBeenCalledWith(expectedUrl, JSON.stringify(expectedPayload), {
      headers: expectedHeaders,
    });
    expect(result).toEqual(mockedResponse);
  });

  it("should handle axios.post rejection and call dispatchError", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_DOCUMENTS_END_POINT = "/documents-endpoint/";
    process.env.REACT_APP_RTOB_ACKNOWLEDGE_END_POINT = "/acknowledge-endpoint/";

    const mockedError = new Error("mocked_error");
    mockedAxios.post.mockRejectedValueOnce(mockedError);

    const channelReference = "mocked_channel_ref";

    await expect(postFinalAcknowledge(channelReference)).rejects.toThrow("mocked_error");

    expect(dispatchError).toHaveBeenCalledWith(mockedError);
  });
});



import { postQRCodeZOLO } from "./yourFile";
import axios from "axios";
import PreApprovalUtil from "./preApprovalUtils";
import { dispatchError } from "../../../services/common-service";

jest.mock("axios");
jest.mock("./preApprovalUtils", () => ({
  getAckMetaData: jest.fn(),
}));
jest.mock("../../../services/common-service", () => ({
  dispatchError: jest.fn(),
}));

const mockedAxios = axios as jest.Mocked<typeof axios>;

describe("postQRCodeZOLO", () => {
  beforeEach(() => {
    mockedAxios.post.mockReset();
    PreApprovalUtil.getAckMetaData.mockReturnValue("mocked_ack_meta_data");
  });

  it("should call axios.post with correct arguments and resolve", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_QRCODE_SMART_HKID_END_POINT = "/qrcode-endpoint/";

    const mockedResponse = { data: "mocked_response" };
    mockedAxios.post.mockResolvedValueOnce(mockedResponse);

    const channelReference = "mocked_channel_ref";
    const docType = "HKID";

    const result = await postQRCodeZOLO(channelReference, docType);

    const expectedUrl =
      "https://mock-base-url/application-endpoint/mocked_channel_ref/qrcode-endpoint/";
    const expectedPayload = {
      docType: "HKID",
      qrCodeFlag: "Y",
      h5ModeConfig: {
        completeCallbackUrl:
          "https://pt.sc.com/onboarding/hk/zolozThankYou.html?scbToken=mocked_channel_ref&lang=en",
        interruptCallbackUrl:
          "https://pt.sc.com/onboarding/hk/zoloz-error.html?scbToken=mocked_channel_ref&lang=en",
        locale: "",
      },
    };
    const expectedHeaders = {
      "Content-Type": "application/json;charset=UTF-8",
      "Sc-Client-Context": "mocked_ack_meta_data",
    };

    expect(mockedAxios.post).toHaveBeenCalledWith(expectedUrl, JSON.stringify(expectedPayload), {
      headers: expectedHeaders,
    });
    expect(result).toEqual(mockedResponse);
  });

  it("should handle axios.post rejection and call dispatchError", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_QRCODE_SMART_HKID_END_POINT = "/qrcode-endpoint/";

    const mockedError = new Error("mocked_error");
    mockedAxios.post.mockRejectedValueOnce(mockedError);

    const channelReference = "mocked_channel_ref";
    const docType = "HKID";

    await expect(postQRCodeZOLO(channelReference, docType)).rejects.toThrow("mocked_error");

   

import { postPdfPreview } from "./yourFile";
import axios from "axios";
import { store } from "../../../utils/store/store";
import PreApprovalUtil from "./preApprovalUtils";
import { dispatchError } from "../../../services/common-service";

jest.mock("axios");
jest.mock("../../../utils/store/store", () => ({
  store: {
    getState: jest.fn(),
  },
}));
jest.mock("./preApprovalUtils", () => ({
  getAckMetaData: jest.fn(),
}));
jest.mock("../../../services/common-service", () => ({
  dispatchError: jest.fn(),
}));

const mockedAxios = axios as jest.Mocked<typeof axios>;

describe("postPdfPreview", () => {
  beforeEach(() => {
    mockedAxios.post.mockReset();
    (store.getState as jest.Mock).mockReturnValue({
      stages: {
        stages: [
          {
            stageInfo: {
              application: {
                channel_reference: "mocked_channel_ref",
                application_reference: "mocked_application_ref",
              },
            },
          },
        ],
      },
    });

    PreApprovalUtil.getAckMetaData.mockReturnValue("mocked_ack_meta_data");
  });

  it("should call axios.post with correct arguments and resolve", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_DYNAMIC_DOCUMENT = "/dynamic-doc/";
    process.env.REACT_APP_RTOB_PDF_PREVIEW = "/pdf-preview/";

    const mockedResponse = { data: "mocked_response" };
    mockedAxios.post.mockResolvedValueOnce(mockedResponse);

    const channelReference = "mocked_channel_ref";

    const result = await postPdfPreview(channelReference);

    const expectedUrl = "https://mock-base-url/dynamic-doc/mocked_channel_ref/pdf-preview/";
    const expectedPayload = {
      appInRefNumber: "mocked_application_ref",
      template_name: "ekyc_report",
      action: "generate",
      page_id: "HK_ALIPAY_AOF_ENG.thy",
    };
    const expectedHeaders = {
      "Content-Type": "application/json;charset=UTF-8",
      "Sc-Client-Context": "mocked_ack_meta_data",
    };

    expect(mockedAxios.post).toHaveBeenCalledWith(expectedUrl, JSON.stringify(expectedPayload), {
      headers: expectedHeaders,
    });
    expect(result).toEqual(mockedResponse);
  });

  it("should handle axios.post rejection and call dispatchError", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_DYNAMIC_DOCUMENT = "/dynamic-doc/";
    process.env.REACT_APP_RTOB_PDF_PREVIEW = "/pdf-preview/";

    const mockedError = new Error("mocked_error");
    mockedAxios.post.mockRejectedValueOnce(mockedError);

    const channelReference = "mocked_channel_ref";

    await expect(postPdfPreview(channelReference)).rejects.toThrow("mocked_error");

    expect(dispatchError).toHaveBeenCalledWith(mockedError);
  });
});

import { postTMXUserSession } from "./yourFile";
import axios from "axios";
import { store } from "../../../utils/store/store";
import PreApprovalUtil from "./preApprovalUtils";
import { dispatchError } from "../../../services/common-service";

jest.mock("axios");
jest.mock("../../../utils/store/store", () => ({
  store: {
    getState: jest.fn(),
  },
}));
jest.mock("./preApprovalUtils", () => ({
  getAckMetaData: jest.fn(),
}));
jest.mock("../../../services/common-service", () => ({
  dispatchError: jest.fn(),
}));

const mockedAxios = axios as jest.Mocked<typeof axios>;

describe("postTMXUserSession", () => {
  beforeEach(() => {
    mockedAxios.post.mockReset();
    (store.getState as jest.Mock).mockReturnValue({
      stages: {
        stages: [
          {
            stageInfo: {
              application: {
                cos_ref_number: "mocked_cos_ref_number",
              },
            },
          },
        ],
      },
    });

    PreApprovalUtil.getAckMetaData.mockReturnValue("mocked_ack_meta_data");
  });

  it("should call axios.post with correct arguments and resolve", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_VERIFY_TMX_USER_SESSION = "/tmx-session/";

    const mockedResponse = { data: "mocked_response" };
    mockedAxios.post.mockResolvedValueOnce(mockedResponse);

    const channelReference = "mocked_channel_ref";

    const result = await postTMXUserSession(channelReference);

    const expectedUrl = "https://mock-base-url/application-endpoint/mocked_channel_ref/tmx-session/";
    const expectedPayload = {
      session_id_tmx: "0e741a59-94e9-4603-b3fd-b0139e14583d",
      cos_ref_number: "mocked_cos_ref_number",
    };
    const expectedHeaders = {
      "Content-Type": "application/json;charset=UTF-8",
      "Sc-Client-Context": "mocked_ack_meta_data",
    };

    expect(mockedAxios.post).toHaveBeenCalledWith(expectedUrl, JSON.stringify(expectedPayload), {
      headers: expectedHeaders,
    });
    expect(result).toEqual(mockedResponse);
  });

  it("should handle axios.post rejection and call dispatchError", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_VERIFY_TMX_USER_SESSION = "/tmx-session/";

    const mockedError = new Error("mocked_error");
    mockedAxios.post.mockRejectedValueOnce(mockedError);

    const channelReference = "mocked_channel_ref";

    await expect(postTMXUserSession(channelReference)).rejects.toThrow("mocked_error");

    expect(dispatchError).toHaveBeenCalledWith(mockedError);
  });
});




import { postFulFilmentData } from "./yourFile";
import axios from "axios";
import { store } from "../../../utils/store/store";
import PreApprovalUtil from "./preApprovalUtils";
import { dispatchError } from "../../../services/common-service";

jest.mock("axios");
jest.mock("../../../utils/store/store", () => ({
  store: {
    getState: jest.fn(),
  },
}));
jest.mock("./preApprovalUtils", () => ({
  getAckMetaData: jest.fn(),
}));
jest.mock("../../../services/common-service", () => ({
  dispatchError: jest.fn(),
}));

const mockedAxios = axios as jest.Mocked<typeof axios>;

describe("postFulFilmentData", () => {
  beforeEach(() => {
    mockedAxios.post.mockReset();
    (store.getState as jest.Mock).mockReturnValue({
      stages: {
        stages: [
          {
            stageInfo: {
              application: {
                channel_reference: "mocked_channel_ref",
              },
            },
            stageId: "stage-id-1",
          },
        ],
      },
    });

    PreApprovalUtil.getAckMetaData.mockReturnValue("mocked_ack_meta_data");
  });

  it("should call axios.post with correct arguments and resolve", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_FULFILMENT_DATA = "/fulfilment-data/";

    const mockedResponse = { data: "mocked_response" };
    mockedAxios.post.mockResolvedValueOnce(mockedResponse);

    const payload = {
      applicants: [{ id: "applicant-id-1" }],
      application: { id: "application-id-1" },
      stage: {},
    };

    const result = await postFulFilmentData(payload);

    const expectedUrl =
      "https://mock-base-url/application-endpoint/mocked_channel_ref/fulfilment-data/";
    const expectedHeaders = {
      "Content-Type": "application/json;charset=UTF-8",
      "Sc-Client-Context": "mocked_ack_meta_data",
    };

    const expectedPayload = JSON.stringify({
      ...payload,
      stage: {
        page_id: "stage-id-1",
        workflow_stage_id: "STAGE",
        stage_id: "STAGEID1",
        stage_status: "incomplete",
        stage_params: {
          is_dedupe_required: false,
          current_applicant: 0,
          eb_status: null,
        },
      },
      status_data: null,
      preapproved: null,
      temp_login_data: null,
      service_response: null,
      application: {
        ...payload.application,
        service_type: "STAGEID1",
        alipay_ref_number: null,
        ext_acceptance_reference_number: null,
        ext_authentication_reference_number: null,
        stage_wise: null,
        version: null,
        source_system_name: "3",
        page_wise: null,
      },
      client: {
        journey: "prelogin_ntc_or_ntp",
        auth_type: "manual",
        login_type: "prelogin",
      },
    });

    expect(mockedAxios.post).toHaveBeenCalledWith(expectedUrl, expectedPayload, {
      headers: expectedHeaders,
    });
    expect(result).toEqual(mockedResponse);
  });

  it("should handle axios.post rejection and call dispatchError", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_FULFILMENT_DATA = "/fulfilment-data/";

    const mockedError = new Error("mocked_error");
    mockedAxios.post.mockRejectedValueOnce(mockedError);

    const payload = {
      applicants: [{ id: "applicant-id-1" }],
      application: { id: "application-id-1" },
      stage: {},
    };

    await expect(postFulFilmentData(payload)).rejects.toThrow("mocked_error");

    expect(dispatchError).toHaveBeenCalledWith(mockedError);
  });




import { postAditionalData } from "./yourFile";
import axios from "axios";
import { store } from "../../../utils/store/store";
import PreApprovalUtil from "./preApprovalUtils";
import { dispatchError } from "../../../services/common-service";
import { adpayload } from "./payload";

jest.mock("axios");
jest.mock("../../../utils/store/store", () => ({
  store: {
    getState: jest.fn(),
  },
}));
jest.mock("./preApprovalUtils", () => ({
  getAckMetaData: jest.fn(),
  getFormConfigPayload: jest.fn(),
}));
jest.mock("../../../services/common-service", () => ({
  dispatchError: jest.fn(),
}));
jest.mock("./payload", () => ({
  adpayload: jest.fn(() => ({
    applicants: [],
    fieldmetadata: {},
    products: [],
    stage: {},
    status: {},
    applicant_documents: [],
    client: {},
    dedupe: {},
    dedupeList: [],
    etc_data: {},
    lov_desc: {},
    oz_templates: [],
    preApprovedData: {},
    preapproved: {},
    service_response: {},
  })),
}));

const mockedAxios = axios as jest.Mocked<typeof axios>;

describe("postAditionalData", () => {
  beforeEach(() => {
    mockedAxios.post.mockReset();
    (store.getState as jest.Mock).mockReturnValue({
      stages: {
        stages: [
          {
            stageInfo: {
              application: {
                channel_reference: "mocked_channel_ref",
              },
            },
          },
        ],
      },
    });

    PreApprovalUtil.getAckMetaData.mockReturnValue("mocked_ack_meta_data");
    PreApprovalUtil.getFormConfigPayload.mockReturnValue({
      applicants: [{ id: "applicant-id" }],
      fieldmetadata: {},
      products: [],
      stage: {},
      status: {},
      applicant_documents: [],
      client: {},
      dedupe: {},
      dedupeList: [],
      etc_data: {},
      lov_desc: {},
      oz_templates: [],
      preApprovedData: {},
      preapproved: {},
      service_response: {},
    });
  });

  it("should call axios.post with correct arguments and resolve", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_ADDITIONAL_DATA_END_POINT = "/additional-data/";

    const mockedResponse = { data: "mocked_response" };
    mockedAxios.post.mockResolvedValueOnce(mockedResponse);

    const result = await postAditionalData();

    const expectedUrl =
      "https://mock-base-url/application-endpoint/mocked_channel_ref/additional-data/";
    const currentStageData = PreApprovalUtil.getFormConfigPayload();
    const expectedPayload = {
      ...adpayload(),
      applicants: currentStageData.applicants,
      fieldmetadata: currentStageData.fieldmetadata,
      products: currentStageData.products,
      stage: currentStageData.stage,
      status: currentStageData.status,
      applicant_documents: currentStageData.applicant_documents,
      client: currentStageData.client,
      dedupe: currentStageData.dedupe,
      dedupeList: currentStageData.dedupeList,
      etc_data: currentStageData.etc_data,
      lov_desc: currentStageData.lov_desc,
      oz_templates: currentStageData.oz_templates,
      preApprovedData: currentStageData.preApprovedData,
      preapproved: currentStageData.preapproved,
      service_response: currentStageData.service_response,
    };
    const expectedHeaders = {
      "Content-Type": "application/json;charset=UTF-8",
      "Sc-Client-Context": "mocked_ack_meta_data",
    };

    expect(mockedAxios.post).toHaveBeenCalledWith(expectedUrl, JSON.stringify(expectedPayload), {
      headers: expectedHeaders,
    });
    expect(result).toEqual(mockedResponse);
  });

  it("should handle axios.post rejection and call dispatchError", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_ADDITIONAL_DATA_END_POINT = "/additional-data/";

    const mockedError = new Error("mocked_error");
    mockedAxios.post.mockRejectedValueOnce(mockedError);

    await expect(postAditionalData()).rejects.toThrow("mocked_error");

    expect(dispatchError).toHaveBeenCalledWith(mockedError);
  });
});
});



import { postDocumemts } from "./yourFile";
import axios from "axios";
import PreApprovalUtil from "./preApprovalUtils";
import { dispatchError } from "../../../services/common-service";

jest.mock("axios");
jest.mock("./preApprovalUtils", () => ({
  getAckMetaData: jest.fn(),
}));
jest.mock("../../../services/common-service", () => ({
  dispatchError: jest.fn(),
}));

const mockedAxios = axios as jest.Mocked<typeof axios>;

describe("postDocumemts", () => {
  beforeEach(() => {
    mockedAxios.post.mockReset();
    PreApprovalUtil.getAckMetaData.mockReturnValue("mocked_ack_meta_data");
  });

  it("should call axios.post with correct arguments and resolve", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_DOCUMENTS_END_POINT = "/documents-endpoint/";

    const mockedResponse = { data: "mocked_response" };
    mockedAxios.post.mockResolvedValueOnce(mockedResponse);

    const channelReference = "mocked_channel_ref";
    const file = new File(["dummy content"], "testDocument.pdf", { type: "application/pdf" });

    const result = await postDocumemts(channelReference, file);

    const expectedUrl =
      "https://mock-base-url/application-endpoint/mocked_channel_ref/documents-endpoint/";

    // Check that the `axios.post` is called with a FormData object
    expect(mockedAxios.post).toHaveBeenCalledWith(expectedUrl, expect.any(FormData), {
      headers: {
        "Content-Type": "multipart/form-data",
        "Sc-Client-Context": "mocked_ack_meta_data",
      },
    });

    // Ensure the result matches the mocked response
    expect(result).toEqual(mockedResponse);

    // Check FormData contents
    const formData = new FormData();
    formData.append("file", file, "testDocument.pdf");
    formData.append(
      "documentJson",
      JSON.stringify({
        origin: "front-line-supporting-document",
        documentCategoryCode: "R0005",
        documentTypeCode: "A023",
        applicantId: 1,
        imageOrder: 5,
        period: 0,
        isWatermarkRequired: "N",
        documentOptionSequence: "undefined",
      })
    );
  });

  it("should handle axios.post rejection and call dispatchError", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_DOCUMENTS_END_POINT = "/documents-endpoint/";

    const mockedError = new Error("mocked_error");
    mockedAxios.post.mockRejectedValueOnce(mockedError);

    const channelReference = "mocked_channel_ref";
    const file = new File(["dummy content"], "testDocument.pdf", { type: "application/pdf" });

    await expect(postDocumemts(channelReference, file)).rejects.toThrow("mocked_error");

    expect(dispatchError).toHaveBeenCalledWith(mockedError);
  });
});

import { postBasicData } from "./yourFile";
import axios from "axios";
import { store } from "../../../utils/store/store";
import PreApprovalUtil from "./preApprovalUtils";
import { dispatchError } from "../../../services/common-service";

jest.mock("axios");
jest.mock("../../../utils/store/store", () => ({
  store: {
    getState: jest.fn(),
  },
}));
jest.mock("./preApprovalUtils", () => ({
  getFormConfigPayload: jest.fn(),
  getAckMetaData: jest.fn(),
}));
jest.mock("../../../services/common-service", () => ({
  dispatchError: jest.fn(),
}));

const mockedAxios = axios as jest.Mocked<typeof axios>;

describe("postBasicData", () => {
  beforeEach(() => {
    mockedAxios.post.mockReset();
    (store.getState as jest.Mock).mockReturnValue({
      stages: {
        stages: [
          {
            stageInfo: {
              application: {
                channel_reference: "mocked_channel_ref",
              },
            },
          },
        ],
      },
    });

    PreApprovalUtil.getFormConfigPayload.mockReturnValue({
      applicants: [],
      application: {},
    });

    PreApprovalUtil.getAckMetaData.mockReturnValue("mocked_ack_meta_data");
  });

  it("should call axios.post with correct arguments and resolve", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_BASIC_DATA_END_POINT = "/basic-data/";

    const mockedResponse = { data: "mocked_response" };
    mockedAxios.post.mockResolvedValueOnce(mockedResponse);

    const result = await postBasicData();

    const expectedUrl =
      "https://mock-base-url/application-endpoint/mocked_channel_ref/basic-data/";
    const expectedPayload = JSON.stringify({
      applicants: [],
      application: {},
    });
    const expectedHeaders = {
      "Content-Type": "application/json;charset=UTF-8",
      "Sc-Client-Context": "mocked_ack_meta_data",
    };

    expect(mockedAxios.post).toHaveBeenCalledWith(expectedUrl, expectedPayload, {
      headers: expectedHeaders,
    });
    expect(result).toEqual(mockedResponse);
  });

  it("should handle axios.post rejection and call dispatchError", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_BASIC_DATA_END_POINT = "/basic-data/";

    const mockedError = new Error("mocked_error");
    mockedAxios.post.mockRejectedValueOnce(mockedError);

    await expect(postBasicData()).rejects.toThrow("mocked_error");

    expect(dispatchError).toHaveBeenCalledWith(mockedError);
  });
});

import { postAditionalData } from "./yourFile";
import axios from "axios";
import { store } from "../../../utils/store/store";
import PreApprovalUtil from "./preApprovalUtils";
import { dispatchError } from "../../../services/common-service";
import { adpayload } from "./payload";

jest.mock("axios");
jest.mock("../../../utils/store/store", () => ({
  store: {
    getState: jest.fn(),
  },
}));
jest.mock("./preApprovalUtils", () => ({
  getAckMetaData: jest.fn(),
  getFormConfigPayload: jest.fn(),
}));
jest.mock("../../../services/common-service", () => ({
  dispatchError: jest.fn(),
}));
jest.mock("./payload", () => ({
  adpayload: jest.fn(() => ({
    applicants: [],
    fieldmetadata: {},
    products: [],
    stage: {},
    status: {},
    applicant_documents: [],
    client: {},
    dedupe: {},
    dedupeList: [],
    etc_data: {},
    lov_desc: {},
    oz_templates: [],
    preApprovedData: {},
    preapproved: {},
    service_response: {},
  })),
}));

const mockedAxios = axios as jest.Mocked<typeof axios>;

describe("postAditionalData", () => {
  beforeEach(() => {
    mockedAxios.post.mockReset();
    (store.getState as jest.Mock).mockReturnValue({
      stages: {
        stages: [
          {
            stageInfo: {
              application: {
                channel_reference: "mocked_channel_ref",
              },
            },
          },
        ],
      },
    });

    PreApprovalUtil.getAckMetaData.mockReturnValue("mocked_ack_meta_data");
    PreApprovalUtil.getFormConfigPayload.mockReturnValue({
      applicants: [{ id: "applicant-id" }],
      fieldmetadata: {},
      products: [],
      stage: {},
      status: {},
      applicant_documents: [],
      client: {},
      dedupe: {},
      dedupeList: [],
      etc_data: {},
      lov_desc: {},
      oz_templates: [],
      preApprovedData: {},
      preapproved: {},
      service_response: {},
    });
  });

  it("should call axios.post with correct arguments and resolve", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_ADDITIONAL_DATA_END_POINT = "/additional-data/";

    const mockedResponse = { data: "mocked_response" };
    mockedAxios.post.mockResolvedValueOnce(mockedResponse);

    const result = await postAditionalData();

    const expectedUrl =
      "https://mock-base-url/application-endpoint/mocked_channel_ref/additional-data/";
    const currentStageData = PreApprovalUtil.getFormConfigPayload();
    const expectedPayload = {
      ...adpayload(),
      applicants: currentStageData.applicants,
      fieldmetadata: currentStageData.fieldmetadata,
      products: currentStageData.products,
      stage: currentStageData.stage,
      status: currentStageData.status,
      applicant_documents: currentStageData.applicant_documents,
      client: currentStageData.client,
      dedupe: currentStageData.dedupe,
      dedupeList: currentStageData.dedupeList,
      etc_data: currentStageData.etc_data,
      lov_desc: currentStageData.lov_desc,
      oz_templates: currentStageData.oz_templates,
      preApprovedData: currentStageData.preApprovedData,
      preapproved: currentStageData.preapproved,
      service_response: currentStageData.service_response,
    };
    const expectedHeaders = {
      "Content-Type": "application/json;charset=UTF-8",
      "Sc-Client-Context": "mocked_ack_meta_data",
    };

    expect(mockedAxios.post).toHaveBeenCalledWith(expectedUrl, JSON.stringify(expectedPayload), {
      headers: expectedHeaders,
    });
    expect(result).toEqual(mockedResponse);
  });

  it("should handle axios.post rejection and call dispatchError", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_ADDITIONAL_DATA_END_POINT = "/additional-data/";

    const mockedError = new Error("mocked_error");
    mockedAxios.post.mockRejectedValueOnce(mockedError);

    await expect(postAditionalData()).rejects.toThrow("mocked_error");

    expect(dispatchError).toHaveBeenCalledWith(mockedError);
 
import { postAditionalData } from "./yourFile";
import axios from "axios";
import { store } from "../../../utils/store/store";
import PreApprovalUtil from "./preApprovalUtils";
import { dispatchError } from "../../../services/common-service";
import { adpayload } from "./payload";

jest.mock("axios");
jest.mock("../../../utils/store/store", () => ({
  store: {
    getState: jest.fn(),
  },
}));
jest.mock("./preApprovalUtils", () => ({
  getAckMetaData: jest.fn(),
  getADFormConfigPayload: jest.fn(),
}));
jest.mock("../../../services/common-service", () => ({
  dispatchError: jest.fn(),
}));
jest.mock("./payload", () => ({
  adpayload: jest.fn(() => ({
    applicants: [],
    fieldmetadata: {},
    products: [],
    stage: {},
    status: {},
    applicant_documents: [],
    client: {},
    dedupe: {},
    dedupeList: [],
    etc_data: {},
    lov_desc: {},
    oz_templates: [],
    preApprovedData: {},
    preapproved: {},
    service_response: {},
  })),
}));

const mockedAxios = axios as jest.Mocked<typeof axios>;

describe("postAditionalData", () => {
  beforeEach(() => {
    mockedAxios.post.mockReset();
    (store.getState as jest.Mock).mockReturnValue({
      stages: {
        stages: [
          {
            stageInfo: {
              application: {
                channel_reference: "mocked_channel_ref",
              },
            },
          },
        ],
      },
    });

    PreApprovalUtil.getAckMetaData.mockReturnValue("mocked_ack_meta_data");
  });

  it("should call axios.post with correct arguments and resolve when payload is an object", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_ADDITIONAL_DATA_END_POINT = "/additional-data/";

    // Mock payload as object
    PreApprovalUtil.getADFormConfigPayload.mockReturnValueOnce({
      applicants: [],
      application: {},
    });

    const mockedResponse = { data: "mocked_response" };
    mockedAxios.post.mockResolvedValueOnce(mockedResponse);

    const result = await postAditionalData();

    const expectedUrl =
      "https://mock-base-url/application-endpoint/mocked_channel_ref/additional-data/";
    const expectedPayload = JSON.stringify({
      ...adpayload(),
      applicants: [],
      application: {},
    });
    const expectedHeaders = {
      "Content-Type": "application/json;charset=UTF-8",
      "Sc-Client-Context": "mocked_ack_meta_data",
    };

    expect(mockedAxios.post).toHaveBeenCalledWith(expectedUrl, expectedPayload, {
      headers: expectedHeaders,
    });
    expect(result).toEqual(mockedResponse);
  });

  it("should call axios.post with correct arguments and resolve when payload is a JSON string", async () => {
    // Mock payload as JSON string
    PreApprovalUtil.getADFormConfigPayload.mockReturnValueOnce(
      JSON.stringify({
        applicants: [],
        application: {},
      })
    );

    const mockedResponse = { data: "mocked_response" };
    mockedAxios.post.mockResolvedValueOnce(mockedResponse);

    const result = await postAditionalData();

    const expectedUrl =
      "https://mock-base-url/application-endpoint/mocked_channel_ref/additional-data/";
    const expectedPayload = JSON.stringify({
      ...adpayload(),
      applicants: [],
      application: {},
    });
    const expectedHeaders = {
      "Content-Type": "application/json;charset=UTF-8",
      "Sc-Client-Context": "mocked_ack_meta_data",
    };

    expect(mockedAxios.post).toHaveBeenCalledWith(expectedUrl, expectedPayload, {
      headers: expectedHeaders,
    });
    expect(result).toEqual(mockedResponse);
  });

  it("should handle invalid JSON returned by getADFormConfigPayload", async () => {
    PreApprovalUtil.getADFormConfigPayload.mockReturnValueOnce("{invalidJSON}");

    await expect(postAditionalData()).rejects.toThrow(
      "Failed to parse getADFormConfigPayload: Invalid JSON string"
    );
  });

  it("should handle undefined or null return value from getADFormConfigPayload", async () => {
    PreApprovalUtil.getADFormConfigPayload.mockReturnValueOnce(undefined);

    await expect(postAditionalData()).rejects.toThrow(
      "getADFormConfigPayload returned undefined or null"
    );
  });

  it("should handle axios.post rejection and call dispatchError", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_ADDITIONAL_DATA_END_POINT = "/additional-data/";

    const mockedError = new Error("mocked_error");
    mockedAxios.post.mockRejectedValueOnce(mockedError);

    await expect(postAditionalData()).rejects.toThrow("mocked_error");

    expect(dispatchError).toHaveBeenCalledWith(mockedError);
  });
});
