import { createSlice } from "@reduxjs/toolkit";
import {taxStoreModel} from '../model/common-model'
const initialState: taxStoreModel = {
        maxCount: 5,
        count: 0,
        fields: []
};

const tax = createSlice({
        name: "tax",
        initialState,
        reducers: {
                addTaxFiled(state, action) {
                        state.fields.push(action.payload);
                },
                updateCount(state, action) {
                        state.count = action.payload;
                },
                removeTaxField(state, action) {
                       // if (state.count >= 0) {
                           if(action.payload!=="no_of_tax_residency_country"){
                                state.count = --state.count;
                                let findIndex = state.fields.findIndex(
                                        (field: string) => field === action.payload
                                );
                                state.fields.splice(findIndex,1);
                           }
                       // }
                        
                },
                updateTax(state, action) {
                        const updatedFields = [...state.fields]; 
                        const [field, value] = Object.entries(action.payload)[0];
                      
                        const normalizedField = field.replace(/_a_\d+$/, '');
                      
                        const index = updatedFields.findIndex(
                          (item) => item.replace(/_a_\d+$/, '') === normalizedField
                        );
                       const taxField = `tax_id_no_${field.split("_")[4]}`;
                       const reasonField = `crs_reason_code_${field.split("_")[4]}`;
                //        if(field.startsWith('crs_comments')){
                //         debugger
                //         const crsCommentsField = `crs_comments_${field.split("_")[2]}`;
                //         const existCrsComments = updatedFields.includes(crsCommentsField);         
                //         if (!existCrsComments) {
                //                 updatedFields.splice(index + 1, 0, `tax_id_no_${field.split("_")[4]}`, `crs_reason_code_${field.split("_")[4]}`, `crs_comments_${field.split("_")[4]}`);
                //         }  
                //        }
                       const taxAlone = updatedFields.includes(taxField)
                       const alreadyExists = updatedFields.includes(taxField) && updatedFields.includes(reasonField);
                      
                        if (value && index !== -1 &&!alreadyExists &&!taxAlone) {
                          updatedFields.splice(index + 1, 0, `tax_id_no_${field.split("_")[4]}`, `crs_reason_code_${field.split("_")[4]}`);
                        }
                      
                        state.fields = updatedFields; // Update state fields
                      }
                      ,
                resetTaxField(state, action) {
                        state.maxCount = 4;
                        state.count = 0;
                        state.fields = action.payload;
                }
        }
});
export const taxAction = tax.actions;
export default tax;






import tax, { taxAction } from "./tax-slice";

describe("tax slice", () => {
  let initialState: any;

  beforeEach(() => {
    initialState = {
      maxCount: 5,
      count: 0,
      fields: [],
    };
  });

  test("should return the initial state", () => {
    expect(tax.reducer(undefined, { type: undefined })).toEqual(initialState);
  });

  test("should add a tax field", () => {
    const newState = tax.reducer(initialState, taxAction.addTaxFiled("taxField1"));
    expect(newState.fields).toContain("taxField1");
  });

  test("should update count", () => {
    const newState = tax.reducer(initialState, taxAction.updateCount(3));
    expect(newState.count).toBe(3);
  });

  test("should remove a tax field", () => {
    const populatedState = {
      ...initialState,
      count: 2,
      fields: ["taxField1", "taxField2"],
    };

    const newState = tax.reducer(populatedState, taxAction.removeTaxField("taxField1"));
    expect(newState.fields).not.toContain("taxField1");
    expect(newState.count).toBe(1);
  });

  test("should NOT remove 'no_of_tax_residency_country' field", () => {
    const populatedState = {
      ...initialState,
      count: 2,
      fields: ["no_of_tax_residency_country", "taxField1"],
    };

    const newState = tax.reducer(populatedState, taxAction.removeTaxField("no_of_tax_residency_country"));
    expect(newState.fields).toContain("no_of_tax_residency_country");
    expect(newState.count).toBe(2);
  });

  test("should not remove field if it does not exist", () => {
    const populatedState = {
      ...initialState,
      count: 2,
      fields: ["taxField1"],
    };

    const newState = tax.reducer(populatedState, taxAction.removeTaxField("nonExistentField"));
    expect(newState.fields.length).toBe(1);
  });

  test("should update tax fields correctly", () => {
    const populatedState = {
      ...initialState,
      fields: ["existing_field"],
    };

    const newState = tax.reducer(populatedState, taxAction.updateTax({ tax_id_no_a_1: "value" }));
    expect(newState.fields).toContain("existing_field");
    expect(newState.fields).toContain("tax_id_no_1");
    expect(newState.fields).toContain("crs_reason_code_1");
  });

  test("should reset tax fields", () => {
    const populatedState = {
      maxCount: 10,
      count: 3,
      fields: ["field1", "field2"],
    };

    const newState = tax.reducer(populatedState, taxAction.resetTaxField([]));
    expect(newState.maxCount).toBe(4);
    expect(newState.count).toBe(0);
    expect(newState.fields).toEqual([]);
  });

  test("should reset tax fields with default value when payload is undefined", () => {
    const populatedState = {
      maxCount: 10,
      count: 3,
      fields: ["field1", "field2"],
    };

    const newState = tax.reducer(populatedState, taxAction.resetTaxField(undefined));
    expect(newState.maxCount).toBe(4);
    expect(newState.count).toBe(0);
    expect(newState.fields).toEqual([]);
  });
});
