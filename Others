 useEffect(() => {
      /*istanbul ignore else*/ 
    if (valueSelector.value !== false) {
      let FieldsIgnore = [
        "client_pl_sc_consent2",
        "client_pl_consent4",
        "client_pl_sc_consent5",
        "client_pl_sc_consent",
        "client_sc_consent_title",
        "client_sc_consent", 
        "client_sc_consent2","sc_tips",
        "sc_tips_pl",
        "name_of_related_person",
        "relationship_of_related_person",
        "total_outstanding_other_loan_amount",
        "total_outstanding_other_monthly_payment",
        "marketing_questionaires",
        "direct_marketing_opt_out",
        "marketing_opt_out",
        "res_floor",
        "res_block",
        "off_floor",
        "off_block","fill_in_note"
      ];
        /*istanbul ignore else*/ 
      if (
        workType === "S001" ||
        workType === "S002" ||
        workType === "S006" ||
        workType === "S103"
      ) {
        FieldsIgnore.push("business_est_date");
      }
        /*istanbul ignore else*/ 
      if(userInputSelector.applicants[0]['id type']==='Passport'){
        FieldsIgnore.push("HKID");
        mandatoryFields.push('passport_no','country_of_issue','expiry_date');
      } 
        /*istanbul ignore else*/ 
      if(userInputSelector.applicants[0].priority_banking ==='Yes' && stageSelector[0].stageId==='ad-5'){
        mandatoryFields.push('rewards_360_indicator');
        FieldsIgnore.push('choice_label','priority_banking');
      }
        /*istanbul ignore else*/ 
      if(userInputSelector.applicants[0].priority_banking ==='No' && stageSelector[0].stageId==='ad-5'){
        FieldsIgnore.push('choice_label','priority_banking','rewards_360_indicator');
      } 
        /*istanbul ignore else*/ 
      if(userInputSelector.applicants[0]['id type']==='HKID'){
        FieldsIgnore.push("Passport");
      }
        /*istanbul ignore else*/ 
      if (fields && fields["fields"] && fields["fields"].length > 0) {
        fields.fields.forEach((res: FieldsetModel) => {
          res.fields.forEach((fName: KeyWithAnyModel) => {
              /*istanbul ignore else*/ 
            if (FieldsIgnore.indexOf(fName.logical_field_name) === -1) {
              if (
                fName.mandatory === "Yes" ||
                fName.mandatory === "Conditional"
              ) {
                let logicalFieldVal =
                  stageSelector[0].stageInfo.applicants[0][
                    fName.logical_field_name + "_a_1"
                  ];
                    /*istanbul ignore else*/ 
                if (!logicalFieldVal) {
                  const fullName =
                    stageSelector[0].stageInfo.applicants[0]["full_name_a_1"];
                  if (fullName && fullName.length >= 19) {
                    const firstName = fullName.split(" ")[0];
                    logicalFieldVal = firstName.length >= 19 ? "" : firstName;
                  } else {
                    logicalFieldVal = fullName;
                  }
                }
                let fieldValue =
                  userInputSelector.applicants[0][fName.logical_field_name];

                if (stageId === CONSTANTS.STAGE_NAMES.AD_2) {
                  value[fName.logical_field_name] = fieldValue
                    ? fieldValue
                    : "";
                  mandatoryFields.push(fName.logical_field_name);
                } else if (stageId === CONSTANTS.STAGE_NAMES.RP) {
                    /*istanbul ignore else*/ 
                  if (fName.logical_field_name === "acknowledgement_cert") {
                    value[fName.logical_field_name] =
                      fieldValue !== "N" ? fieldValue : "";
                    mandatoryFields.push(fName.logical_field_name);
                  }
                    /*istanbul ignore else*/ 
                  if (fName.logical_field_name === "client_declaration_cert") {
                    value[fName.logical_field_name] =
                      fieldValue !== "N" ? fieldValue : "";
                    mandatoryFields.push(fName.logical_field_name);
                  }
                }
                else {
                  value[fName.logical_field_name] = fieldValue
                    ? fieldValue
                    : "";
                  mandatoryFields.push(fName.logical_field_name);
                }
              } else {
                  /*istanbul ignore else*/ 
                if (stageId === CONSTANTS.STAGE_NAMES.BD_1) {
                  const applicants = userInputSelector.applicants[0];
                  const resFloorValue = applicants.res_floor;
                  const resRoomFlatValue = applicants.res_room_flat;
                  const resBlockValue = applicants.res_block;
                  // Add all three back to mandatory if none are filled
                  if (!resFloorValue && !resRoomFlatValue && !resBlockValue) {
                    mandatoryFields = [...mandatoryFields, "res_room_flat"];
                  }
                  else {
                    mandatoryFields = mandatoryFields.filter(
                      (item) => item !== "res_room_flat" && item !== "res_floor" && item !== "res_block"
                    );
                    dispatch(fieldErrorAction.removeToggleFieldError("res_floor"));
                    dispatch(fieldErrorAction.removeToggleFieldError("res_block"));
                  }
                }
                  /*istanbul ignore else*/ 
                if (stageId === CONSTANTS.STAGE_NAMES.AD_3) {
                  const applicants = userInputSelector.applicants[0];
                  const offFloorValue = applicants.off_floor;
                  const offRoomFlatValue = applicants.off_room_flat;
                  const offBlockValue = applicants.off_block;
                  // Add all three back to mandatory if none are filled

                  if (!offFloorValue && !offRoomFlatValue && !offBlockValue) {
                    mandatoryFields = [...mandatoryFields, "off_room_flat"];
                  }
                  else {
                    mandatoryFields = mandatoryFields.filter(
                      (item) => item !== "off_room_flat" && item !== "off_floor" && item !== "off_block"
                    );
                    dispatch(fieldErrorAction.removeToggleFieldError("off_floor"));
                    dispatch(fieldErrorAction.removeToggleFieldError("off_block"));
                  }
                }
              }
            }
          });
        });
        setUserInputs(value);
        dispatch(fieldErrorAction.getMandatoryFields(null));
        dispatch(fieldErrorAction.getMandatoryFields(mandatoryFields));
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [fields, dispatch, valueSelector.value, stageSelector, userInputSelector]);






import { render } from "@testing-library/react";
import { Provider } from "react-redux";
import configureStore from "redux-mock-store";
import Fields from "./fields";
import { fieldErrorAction } from "../../../utils/store/field-error-slice";

jest.mock("../../../utils/store/field-error-slice", () => ({
  fieldErrorAction: {
    getMandatoryFields: jest.fn(),
    removeToggleFieldError: jest.fn(),
  },
}));

const mockStore = configureStore([]);

describe("Fields Component - useEffect Code Coverage", () => {
  let store: any;

  beforeEach(() => {
    store = mockStore({
      stages: {
        stages: [{ stageId: "ad-5", stageInfo: { products: [{ product_type: "PL" }] } }],
        userInput: { applicants: [{ work_type: "S001", priority_banking: "Yes", "id type": "Passport" }] },
      },
      valueUpdate: { value: true },
      fielderror: { mandatoryFields: [], error: [] },
    });

    store.dispatch = jest.fn();
  });

  it("ignores HKID when id type is Passport", () => {
    render(
      <Provider store={store}>
        <Fields />
      </Provider>
    );

    expect(store.dispatch).toHaveBeenCalledWith(
      fieldErrorAction.getMandatoryFields(expect.arrayContaining(["passport_no", "country_of_issue", "expiry_date"]))
    );
  });

  it("adds 'rewards_360_indicator' as a mandatory field when priority banking is Yes", () => {
    render(
      <Provider store={store}>
        <Fields />
      </Provider>
    );

    expect(store.dispatch).toHaveBeenCalledWith(
      fieldErrorAction.getMandatoryFields(expect.arrayContaining(["rewards_360_indicator"]))
    );
  });

  it("removes business_est_date when workType is S001", () => {
    render(
      <Provider store={store}>
        <Fields />
      </Provider>
    );

    expect(store.dispatch).not.toHaveBeenCalledWith(
      fieldErrorAction.getMandatoryFields(expect.arrayContaining(["business_est_date"]))
    );
  });

  it("ignores Passport when id type is HKID", () => {
    store = mockStore({
      ...store,
      stages: {
        ...store.stages,
        userInput: { applicants: [{ "id type": "HKID" }] },
      },
    });

    render(
      <Provider store={store}>
        <Fields />
      </Provider>
    );

    expect(store.dispatch).not.toHaveBeenCalledWith(
      fieldErrorAction.getMandatoryFields(expect.arrayContaining(["Passport"]))
    );
  });

  it("excludes 'rewards_360_indicator' when priority banking is No", () => {
    store = mockStore({
      ...store,
      stages: {
        ...store.stages,
        userInput: { applicants: [{ priority_banking: "No" }] },
      },
    });

    render(
      <Provider store={store}>
        <Fields />
      </Provider>
    );

    expect(store.dispatch).not.toHaveBeenCalledWith(
      fieldErrorAction.getMandatoryFields(expect.arrayContaining(["rewards_360_indicator"]))
    );
  });

  it("removes res_floor, res_block, and res_room_flat if at least one is filled", () => {
    store = mockStore({
      ...store,
      stages: {
        ...store.stages,
        userInput: { applicants: [{ res_floor: "12A", res_block: "", res_room_flat: "" }] },
      },
    });

    render(
      <Provider store={store}>
        <Fields />
      </Provider>
    );

    expect(store.dispatch).toHaveBeenCalledWith(
      fieldErrorAction.removeToggleFieldError("res_floor")
    );
    expect(store.dispatch).toHaveBeenCalledWith(
      fieldErrorAction.removeToggleFieldError("res_block")
    );
  });

  it("adds 'off_room_flat' as mandatory if all office address fields are empty", () => {
    store = mockStore({
      ...store,
      stages: {
        ...store.stages,
        userInput: { applicants: [{ off_floor: "", off_room_flat: "", off_block: "" }] },
      },
    });

    render(
      <Provider store={store}>
        <Fields />
      </Provider>
    );

    expect(store.dispatch).toHaveBeenCalledWith(
      fieldErrorAction.getMandatoryFields(expect.arrayContaining(["off_room_flat"]))
    );
  });

  it("removes 'off_room_flat' from mandatory fields if at least one field is filled", () => {
    store = mockStore({
      ...store,
      stages: {
        ...store.stages,
        userInput: { applicants: [{ off_floor: "5F", off_room_flat: "", off_block: "" }] },
      },
    });

    render(
      <Provider store={store}>
        <Fields />
      </Provider>
    );

    expect(store.dispatch).toHaveBeenCalledWith(
      fieldErrorAction.removeToggleFieldError("off_floor")
    );
    expect(store.dispatch).toHaveBeenCalledWith(
      fieldErrorAction.removeToggleFieldError("off_block")
    );
  });

  it("sets user inputs correctly when fields are populated", () => {
    store = mockStore({
      ...store,
      valueUpdate: { value: true },
      stages: {
        ...store.stages,
        userInput: {
          applicants: [
            {
              "id type": "Passport",
              work_type: "S001",
              priority_banking: "Yes",
              name_of_related_person: "John Doe",
              relationship_of_related_person: "Brother",
              other_loans: "Y",
            },
          ],
        },
      },
    });

    render(
      <Provider store={store}>
        <Fields />
      </Provider>
    );

    expect(store.dispatch).toHaveBeenCalledWith(
      fieldErrorAction.getMandatoryFields(expect.arrayContaining(["passport_no", "country_of_issue", "expiry_date"]))
    );
  });

  it("dispatches mandatory field updates when workType is S103", () => {
    store = mockStore({
      ...store,
      stages: {
        ...store.stages,
        userInput: {
          applicants: [{ work_type: "S103" }],
        },
      },
    });

    render(
      <Provider store={store}>
        <Fields />
      </Provider>
    );

    expect(store.dispatch).toHaveBeenCalled();
  });
});





import configureMockStore from 'redux-mock-store';
import thunk from 'redux-thunk';
import * as stagesAction from '../path-to-actions/stagesAction'; // Update with actual path
import { userInputPayload } from '../path-to-actions/userInputActions'; // Update with actual path
import { CONSTANTS } from '../path-to-constants/constants'; // Update with actual path

// Mock store setup
const middlewares = [thunk];
const mockStore = configureMockStore(middlewares);

describe('User Input Dispatch Tests', () => {
  let store;
  let getStagePayload;
  let userInputSelector;
  let stageSelector;
  let applicantsSelector;
  let userInputs;
  let stageId;
  let continueBtnSelector;
  let setShowSpinner;

  beforeEach(() => {
    store = mockStore({});
    getStagePayload = jest.fn().mockReturnValue({ mockPayload: true });
    setShowSpinner = jest.fn();

    userInputSelector = { applicants: [{ name: 'Test User' }] };
    stageSelector = { stage: 'mock-stage' };
    applicantsSelector = [{ id: 1, name: 'Applicant 1' }];
    userInputs = { key1: 'value1' };
    stageId = CONSTANTS.STAGE_NAMES.PD_1;
    continueBtnSelector = true;
  });

  it('should dispatch user input actions when userInputs is not empty', () => {
    const expectedActions = [
      userInputPayload(getStagePayload(stageSelector, applicantsSelector), stageSelector),
      userInputPayload(userInputSelector.applicants[0], stageSelector),
      stagesAction.resetNewAndOldFields(),
    ];

    if (stageId === CONSTANTS.STAGE_NAMES.PD_1) {
      expectedActions.push(stagesAction.setOtpShow(true));

      if (continueBtnSelector) {
        expectedActions.push(stagesAction.setOtpShow(true));
      }
    }

    // Dispatch actions
    if (Object.keys(userInputs).length > 0) {
      store.dispatch(userInputPayload(getStagePayload(stageSelector, applicantsSelector), stageSelector));
      store.dispatch(userInputPayload(userInputSelector.applicants[0], stageSelector));
      store.dispatch(stagesAction.resetNewAndOldFields());
      setShowSpinner(true);

      if (stageId === CONSTANTS.STAGE_NAMES.PD_1) {
        store.dispatch(stagesAction.setOtpShow(true));
        if (continueBtnSelector === true) {
          store.dispatch(stagesAction.setOtpShow(true));
        }
      }
    }

    expect(store.getActions()).toEqual(expectedActions);
    expect(setShowSpinner).toHaveBeenCalledWith(true);
  });

  it('should not dispatch actions when userInputs is empty', () => {
    userInputs = {}; // Simulating empty object

    // Dispatch actions
    if (Object.keys(userInputs).length > 0) {
      store.dispatch(userInputPayload(getStagePayload(stageSelector, applicantsSelector), stageSelector));
      store.dispatch(userInputPayload(userInputSelector.applicants[0], stageSelector));
      store.dispatch(stagesAction.resetNewAndOldFields());
      setShowSpinner(true);

      if (stageId === CONSTANTS.STAGE_NAMES.PD_1) {
        store.dispatch(stagesAction.setOtpShow(true));
        if (continueBtnSelector === true) {
          store.dispatch(stagesAction.setOtpShow(true));
        }
      }
    }

    expect(store.getActions()).toEqual([]); // No actions should be dispatched
    expect(setShowSpinner).not.toHaveBeenCalled();
  });
});




















import { deleteMandatoryFields } from "../path-to-your-function"; // Update with actual path

describe("deleteMandatoryFields function", () => {
  let userInputs: Record<string, any>;
  let mandatoryFieldSelector: string[];

  beforeEach(() => {
    userInputs = {
      first_name: "John",
      marketing_tooltip: "Some tooltip",
      estatement_tooltip: "Another tooltip",
      field1: "value1",
      field2: "value2",
    };
  });

  it("should delete specified fields when at least one mandatory field is present", () => {
    mandatoryFieldSelector = ["field1", "non_existent_field"];

    deleteMandatoryFields(userInputs, mandatoryFieldSelector);

    expect(userInputs).not.toHaveProperty("first_name");
    expect(userInputs).not.toHaveProperty("marketing_tooltip");
    expect(userInputs).not.toHaveProperty("estatement_tooltip");
    expect(userInputs).toHaveProperty("field2"); // Unrelated field should remain
  });

  it("should not delete fields if no mandatory fields exist in userInputs", () => {
    mandatoryFieldSelector = ["non_existent_field1", "non_existent_field2"];

    deleteMandatoryFields(userInputs, mandatoryFieldSelector);

    expect(userInputs).toHaveProperty("first_name");
    expect(userInputs).toHaveProperty("marketing_tooltip");
    expect(userInputs).toHaveProperty("estatement_tooltip");
    expect(userInputs).toHaveProperty("field1");
    expect(userInputs).toHaveProperty("field2");
  });

  it("should handle an empty mandatoryFieldSelector", () => {
    mandatoryFieldSelector = [];

    deleteMandatoryFields(userInputs, mandatoryFieldSelector);

    expect(userInputs).toHaveProperty("first_name");
    expect(userInputs).toHaveProperty("marketing_tooltip");
    expect(userInputs).toHaveProperty("estatement_tooltip");
  });

  it("should handle an empty userInputs object", () => {
    userInputs = {};
    mandatoryFieldSelector = ["field1"];

    deleteMandatoryFields(userInputs, mandatoryFieldSelector);

    expect(userInputs).toEqual({}); // Should remain empty
  });
});
