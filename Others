import React, {useState} from "react" ;
import { useSelector, useDispatch } from "react-redux";
import { dispatchLoader } from "../../../../../services/common-service";
import { StoreModel } from "../../../../../utils/model/common-model";
import { postDocuments,postZOLOCheck, postZolozAcknowledge,postPdfPreview } from "../../../services/preApprovalPostServices";
import { preApprovalAction } from "../../../store/preApproval-slice";
import Carousel from "../carousel/carousel";
import Modal from "../modals/tipsModal/tips-modal";
import banner1 from "../images-du/illustration-03@3x.png";
import banner2 from "../images-du/illustration-06@3x.png";
import banner3 from "../images-du/illustration-05@3x.png";
import banner4 from "../images-du/illustration-02@3x.png";
import banner5 from "../images-du/illustration-01@3x.png";
import banner6 from "../images-du/illustration-04@3x.png";
import { getImagePreview } from "../../../../preApproval/services/preApprovalServices";


const QRScreen : React.FC<any> =({showUploadFileSuccess, channel_reference, HKIDQRCodeData, HKIDVersionValue, setZolozDocumentData,setShowUploadFileSuccess,
  setDocumentData,
  showQRCodePage,
  setShowQRCodePage,
  setChangeIconColorIdentityProof,
  setShowIncomeProof,
  setDocumentCount,
  documentCount,
  setChangeIconIncomeProof,
  setSucsess,
  setShowContinueBtn,
  setHKIDVersion,

}) =>{
    const dispatch = useDispatch();
    const [isModalOpen, setIsModalOpen] = useState(false);
    const [imagePreview, setImagePreview] = useState(false);
    const [imgeURL, setImageURL] = useState("");
    const [name, setName] = useState("");
    const [validImageSizeModel, setValidImageSizeModel] = useState(false); 
    const [openSuccessModal, setOpenSuccessModal] = useState(false);
    const [continueBtnVisiblity, setContinueBtnVisiblity] = useState(false);



    const filesSelector = useSelector(
        (state: StoreModel) => state.preApproval.incomeProofDocumentUpload
      );
      const imgUrl = useSelector((state: any) => {
        return state?.preApproval?.imgPrevURL;
      });
      const docName = useSelector((state: any) => {
        return state?.preApproval?.documentZoloCheckRes?.data?.documents[0]
          ?.documentName;
      });
      const stageSelector = useSelector(
        (state: StoreModel) => state.stages.stages[0].stageInfo
      );
      const footeContent =
      "File format should be in JPG or PNG. The individual file size must not exceed 5MB. Click";
      const copyRights = "© Standard Chartered Bank (HK) Limited";

    const closeFileUpload = () => {
        // setShowIncomeProof("");
        // setShowQRCodePage(false);
        // setHKIDVersion("");
        // setShowContinueBtn(false);
      };

      const openImagePreview = (img: any, name: any) => {
        setImageURL(img);
        setName(name);
        setImagePreview(true);
      };

      const callModal = () => {
        setIsModalOpen(true);
      };
      const handleRefresh = (fileID: any, index: any) => { };
      const handleDelete = (docId: any) => {
        dispatch(preApprovalAction.setDeleteIncomeProofDocument(docId));
      };

      const handleUploadFile = async (e: any) => {
        const filename = e.target.files[0].name;
        const filesize = `${(e.target.files[0].size / (1024 * 1012)).toFixed(2)}MB`;
        const file = e.target.files[0];
        const maxSize = 5 * 1024 * 1024; //5MB in bytes
    
        if (file.size > maxSize) {
          setValidImageSizeModel(true);
    
          return;
        }
        try {
          await dispatch(dispatchLoader(true));
          const response = await postDocuments(
            channel_reference,
            e.target.files[0]
          );
          const tempData = {
            file: file,
            filename: filename,
            filesize: filesize,
            ...response.data,
          };
    
          if (response.statusText === "Accepted") {
            dispatch(preApprovalAction.setIncomeProofDocumentUpload(tempData));
          }
          await dispatch(dispatchLoader(false));
        } catch (err) {
          console.log("err:", err);
        }
      };

     const okBtnClick = (e: any) => {
    const { title } = e.target;

    if (title === "Colour Identity Proof") {
      setShowIncomeProof("");
      setDocumentCount(documentCount + 1);
      setShowQRCodePage(false);
      setChangeIconColorIdentityProof(false);
    } else if (title === "Income Proof") {
      setContinueBtnVisiblity(true);
      setDocumentCount(documentCount + 1);
      setShowIncomeProof("");
      // changeSuccessState(false);
      // setHKIDVersion("");
      setChangeIconIncomeProof(false);
      setSucsess(true);
    }
    setHKIDVersion("");
    setShowContinueBtn(false);
  };
      const images: any = [
        {
          banner: banner1,
          step: "Step 1",
          stepText: "Scan the QR code with a mobile phone",
        },
        {
          banner: banner2,
          step: "Step 2",
          stepText:
            "Remove card holder and place it on a flat surface under adequate lighting",
        },
        {
          banner: banner3,
          step: "Step 3",
          stepText:
            "Capture ID from above and align the edges with the rectangular frames",
        },
        {
          banner: banner4,
          step: "Step 4",
          stepText: "Tilt mobile phone about 30-degree and capture from aside",
        },
        {
          banner: banner5,
          step: "Step 5",
          stepText:
            "Remove accessories and face mask and place full face in the circular frame and blink once as instructed",
        },
        {
          banner: banner6,
          step: "Step 6",
          stepText: "Return to desktop browser and click “Submit” to continue",
        },
      ];
      const callSubmit = async () => {
        try {
          // setShowSpinner(true);
          dispatch(dispatchLoader(true));
          var transactionId = HKIDQRCodeData.transactionId;
          var docType = HKIDVersionValue;
          var document_type_code =
            stageSelector.applicant_documents[0]?.document_list[0]
              ?.document_options[0]?.document_types[0]?.document_type_code;
          const zoloCheckResponse = await postZOLOCheck(
            channel_reference,
            transactionId,
            docType
          );
          const documents = zoloCheckResponse?.data?.documents || [];
          const docId = documents[0]?.docId;
          setZolozDocumentData(documents[0]);
          const docFilter = documents.filter(
            (item: any) => item.document_type_code === document_type_code
          );
    
          //Update state with ZOLO check response
          dispatch(preApprovalAction.setDocumentZoloCheckRes(zoloCheckResponse));
    
          //Achnowledge the post
          const acknowledgeResponse = await postZolozAcknowledge(
            channel_reference,
            documents
          );
          const resStatus = acknowledgeResponse?.data?.[0]?.responseStatus;
    
          if (resStatus === "Success") {
            setOpenSuccessModal(true);
            setShowUploadFileSuccess(true);
    
            //Fetch and handle image preview
            const imagePreviewResponse = await getImagePreview(
              channel_reference,
              docId
            );
            const blob = imagePreviewResponse?.data;
            const imgObjURL = URL.createObjectURL(blob);
    
            dispatch(preApprovalAction.setImgPrevURL(imgObjURL));
            if (imagePreviewResponse.status === 200) {
              //PDF Preview
              const pdfPreviewRes = await postPdfPreview(channel_reference);
              if (pdfPreviewRes.status >= 200 && pdfPreviewRes.status < 300) {
                if (pdfPreviewRes.data.statusCode.toUpperCase() === "OK") {
                  setDocumentData(pdfPreviewRes.data.documents);
                  //   setShowSpinner(false);
                  dispatch(dispatchLoader(false));
                }
              } else {
                dispatch(dispatchLoader(false));
              }
            }
          }
        } catch (error) {
          console.log("error:", error);
        }
      };
   return(
     <>
            <div className="container">
              <div className="uploadHkDocument">
                <p className="doc-close" onClick={closeFileUpload}>
                  <span className="doc-close-btn"></span>
                  CLOSE
                </p>
                <p className="hk-proof-name">Colour Identity Proof</p>
              </div>
              <div className="qrMainLayOut">
                {!showUploadFileSuccess && (
                  <>
                    {" "}
                    <div className="qrCodeContent">
                      <div className="desktop-img">
                        <Carousel
                          image={images}
                          position={"absolute"}
                          top={"3em"}
                          left={"-4%"}
                          right={"55%"}
                          marginLeft={"20%"}
                          marginTop={"8%"}
                        />
                      </div>
                    </div>
                    <div className="qrImageSection">
                      <img
                        src={`data:image/png;base64,${HKIDQRCodeData?.qrCode}`}
                        alt="ORError"
                      />
                      <div className="qrSubmitButton">
                        <label
                          role="button"
                          title="submit-button"
                          className="upload-btn"
                          onClick={callSubmit}
                        >
                          <span className="upload-img"></span>
                          Submit
                        </label>
                      </div>
                    </div>
                  </>
                )}

                {
                  //onClick={()=>openImagePreview(item.imgurl, item.filename)}
                  showUploadFileSuccess && (
                    <>
                      <div className="upload-btn1" key={"index"}>
                        <div className="thumbnail-img-container">
                          <a>
                            <img
                              title="image-preview"
                              src={imgUrl}
                              onClick={() => openImagePreview(imgUrl, docName)}
                            ></img>
                          </a>
                        </div>
                        <div className="container-image">
                          <div className="uploading-doc-name">
                            <span className="span-file-name">{docName}</span>
                            <div className="progress-text-icon"></div>
                          </div>

                          <div
                            className={
                              "Upload completed" === "Upload completed"
                                ? // docStatus==="UPLOADED"
                                "uploaded"
                                : "retry-uploaded"
                            }
                          ></div>
                          <div
                            className={
                              "Upload completed" === "Upload completed"
                                ? "tick-mark"
                                : "no-tick-mark"
                            }
                          >
                            Upload completed
                          </div>
                        </div>
                      </div>
                    </>
                  )
                }
              </div>
              <div className="hk-copy-rights">
                <p>{copyRights}</p>
              </div>
            </div>
          </>
    
   )

}

export default QRScreen;








import React from "react";
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import { Provider } from "react-redux";
import configureStore from "redux-mock-store";
import QRScreen from "./QRScreen"; // Adjust the path accordingly
import { dispatchLoader } from "../../../../../services/common-service";
import { preApprovalAction } from "../../../store/preApproval-slice";

// Mock dependencies
jest.mock("../../../../../services/common-service", () => ({
  dispatchLoader: jest.fn(),
}));
jest.mock("../../../services/preApprovalPostServices", () => ({
  postDocuments: jest.fn(),
  postZOLOCheck: jest.fn(),
  postZolozAcknowledge: jest.fn(),
  postPdfPreview: jest.fn(),
}));
jest.mock("../../../../preApproval/services/preApprovalServices", () => ({
  getImagePreview: jest.fn(),
}));

// Mock assets
jest.mock("../images-du/illustration-03@3x.png", () => "mockImage1");
jest.mock("../images-du/illustration-06@3x.png", () => "mockImage2");

const mockStore = configureStore([]);

describe("QRScreen Component", () => {
  let store: any;

  const defaultProps = {
    showUploadFileSuccess: false,
    channel_reference: "test-channel",
    HKIDQRCodeData: { qrCode: "test-qr-code", transactionId: "test-tx-id" },
    HKIDVersionValue: "test-version",
    setZolozDocumentData: jest.fn(),
    setShowUploadFileSuccess: jest.fn(),
    setDocumentData: jest.fn(),
    setShowQRCodePage: jest.fn(),
    setChangeIconColorIdentityProof: jest.fn(),
    setShowIncomeProof: jest.fn(),
    setDocumentCount: jest.fn(),
    documentCount: 0,
    setChangeIconIncomeProof: jest.fn(),
    setSucsess: jest.fn(),
    setShowContinueBtn: jest.fn(),
    setHKIDVersion: jest.fn(),
  };

  beforeEach(() => {
    store = mockStore({
      preApproval: {
        incomeProofDocumentUpload: [],
        imgPrevURL: "mock-image-preview-url",
        documentZoloCheckRes: {
          data: {
            documents: [{ documentName: "Test Document" }],
          },
        },
      },
      stages: {
        stages: [
          {
            stageInfo: {
              applicant_documents: [
                {
                  document_list: [
                    {
                      document_options: [
                        {
                          document_types: [
                            { document_type_code: "test-doc-code" },
                          ],
                        },
                      ],
                    },
                  ],
                },
              ],
            },
          },
        ],
      },
    });
  });

  const renderComponent = () =>
    render(
      <Provider store={store}>
        <QRScreen {...defaultProps} />
      </Provider>
    );

  test("renders QRScreen with initial UI elements", () => {
    renderComponent();

    // Check if the main elements render
    expect(screen.getByText(/Colour Identity Proof/i)).toBeInTheDocument();
    expect(screen.getByText(/Scan the QR code/i)).toBeInTheDocument();
    expect(screen.getByAltText(/ORError/i)).toBeInTheDocument();
  });

  test("handles file upload and validates file size", async () => {
    const { postDocuments } = require("../../../services/preApprovalPostServices");

    renderComponent();

    const file = new File(["(⌐□_□)"], "test-image.png", { type: "image/png" });
    const input = screen.getByLabelText("Upload File");

    // Simulate file upload with valid size
    Object.defineProperty(input, "files", {
      value: [file],
    });

    fireEvent.change(input);

    await waitFor(() => {
      expect(dispatchLoader).toHaveBeenCalledWith(true);
      expect(postDocuments).toHaveBeenCalledWith(
        defaultProps.channel_reference,
        file
      );
    });
  });

  test("displays success modal after successful upload", async () => {
    const { postZOLOCheck, postZolozAcknowledge } = require("../../../services/preApprovalPostServices");
    const { getImagePreview } = require("../../../../preApproval/services/preApprovalServices");

    postZOLOCheck.mockResolvedValue({
      data: { documents: [{ docId: "test-doc-id" }] },
    });
    postZolozAcknowledge.mockResolvedValue({
      data: [{ responseStatus: "Success" }],
    });
    getImagePreview.mockResolvedValue({
      data: new Blob(),
      status: 200,
    });

    renderComponent();

    const submitButton = screen.getByTitle("submit-button");
    fireEvent.click(submitButton);

    await waitFor(() => {
      expect(postZOLOCheck).toHaveBeenCalled();
      expect(postZolozAcknowledge).toHaveBeenCalled();
      expect(defaultProps.setShowUploadFileSuccess).toHaveBeenCalledWith(true);
    });
  });

  test("handles image preview click", () => {
    renderComponent();

    // Simulate clicking the image for preview
    const previewImage = screen.getByTitle("image-preview");
    fireEvent.click(previewImage);

    expect(screen.getByText(/Test Document/i)).toBeInTheDocument();
  });

  test("handles closing the file upload section", () => {
    renderComponent();

    const closeButton = screen.getByText(/CLOSE/i);
    fireEvent.click(closeButton);

    expect(defaultProps.setShowQRCodePage).toHaveBeenCalledWith(false);
  });

  test("validates file size limit", async () => {
    renderComponent();

    const oversizedFile = new File(["a".repeat(6 * 1024 * 1024)], "oversize.png", {
      type: "image/png",
    });

    const input = screen.getByLabelText("Upload File");
    Object.defineProperty(input, "files", {
      value: [oversizedFile],
    });

    fireEvent.change(input);

    await waitFor(() => {
      expect(screen.getByText(/File size must not exceed 5MB/i)).toBeInTheDocument();
    });
  });
});








it('calls the callSubmit function and handles success response', async () => {
  // Mock successful API responses
  const mockZoloCheckResponse = {
    data: {
      documents: [
        {
          docId: 'doc123',
          document_type_code: 'TYPE001',
        },
      ],
    },
  };
  const mockAcknowledgeResponse = {
    data: [
      {
        responseStatus: 'Success',
      },
    ],
  };
  const mockPdfPreviewResponse = {
    status: 200,
    data: {
      statusCode: 'OK',
      documents: [],
    },
  };
  const mockImagePreviewBlob = new Blob(['mockImageData'], { type: 'image/png' });

  (preApprovalServices.postZOLOCheck as jest.Mock).mockResolvedValue(mockZoloCheckResponse);
  (preApprovalServices.postZolozAcknowledge as jest.Mock).mockResolvedValue(mockAcknowledgeResponse);
  (preApprovalServices.postPdfPreview as jest.Mock).mockResolvedValue(mockPdfPreviewResponse);
  (preApprovalServices.getImagePreview as jest.Mock).mockResolvedValue({
    data: mockImagePreviewBlob,
  });

  const { props } = setup();

  // Simulate clicking the submit button
  fireEvent.click(screen.getByRole('button', { name: /submit/i }));

  await waitFor(() => {
    // Ensure APIs are called in the correct order with expected arguments
    expect(preApprovalServices.postZOLOCheck).toHaveBeenCalledWith(
      mockChannelReference,
      mockHKIDQRCodeData.transactionId,
      'version1'
    );
    expect(preApprovalServices.postZolozAcknowledge).toHaveBeenCalledWith(
      mockChannelReference,
      mockZoloCheckResponse.data.documents
    );
    expect(preApprovalServices.getImagePreview).toHaveBeenCalledWith(
      mockChannelReference,
      'doc123'
    );
    expect(preApprovalServices.postPdfPreview).toHaveBeenCalledWith(mockChannelReference);

    // Ensure props functions are called to update state
    expect(props.setZolozDocumentData).toHaveBeenCalledWith(mockZoloCheckResponse.data.documents[0]);
    expect(props.setShowUploadFileSuccess).toHaveBeenCalledWith(true);
    expect(props.setDocumentData).toHaveBeenCalledWith(mockPdfPreviewResponse.data.documents);
  });
});

it('handles error in callSubmit gracefully', async () => {
  // Mock API responses with an error
  (preApprovalServices.postZOLOCheck as jest.Mock).mockRejectedValue(new Error('ZOLOCheck failed'));
  const { props } = setup();

  // Simulate clicking the submit button
  fireEvent.click(screen.getByRole('button', { name: /submit/i }));

  await waitFor(() => {
    // Ensure the ZOLO check API was called
    expect(preApprovalServices.postZOLOCheck).toHaveBeenCalledWith(
      mockChannelReference,
      mockHKIDQRCodeData.transactionId,
      'version1'
    );

    // Ensure the subsequent API calls are not made
    expect(preApprovalServices.postZolozAcknowledge).not.toHaveBeenCalled();
    expect(preApprovalServices.getImagePreview).not.toHaveBeenCalled();
    expect(preApprovalServices.postPdfPreview).not.toHaveBeenCalled();

    // No state updates should happen on failure
    expect(props.setZolozDocumentData).not.toHaveBeenCalled();
    expect(props.setShowUploadFileSuccess).not.toHaveBeenCalled();
    expect(props.setDocumentData).not.toHaveBeenCalled();
  });
});
