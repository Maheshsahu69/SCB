 describe("postDocuments", () => {
    beforeEach(() => {
      mockedAxios.post.mockReset();
      (PreApprovalUtil.getAckMetaData as jest.Mock).mockReturnValue(
        "mocked_ack_meta_data"
      );
    });

    it("should call axios.post with correct arguments and resolve", async () => {
      // Mock environment variables
      process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
      process.env.REACT_APP_RTOB_APPLICATION_END_POINT =
        "/application-endpoint/";
      process.env.REACT_APP_RTOB_DOCUMENTS_END_POINT = "/documents-endpoint/";

      const mockedResponse = { data: "mocked_response" };
      mockedAxios.post.mockResolvedValueOnce(mockedResponse);

      const channelReference = "mocked_channel_ref";
      const file = new File(["dummy content"], "testDocument.pdf", {
        type: "application/pdf",
      });

      const result = await postDocuments(channelReference, file);
      expect(result).toEqual(mockedResponse);

      // Check FormData contents
      const formData = new FormData();
      formData.append("file", file, "testDocument.pdf");
      formData.append(
        "documentJson",
        JSON.stringify({
          origin: "front-line-supporting-document",
          documentCategoryCode: "R0005",
          documentTypeCode: "A023",
          applicantId: 1,
          imageOrder: 5,
          period: 0,
          isWatermarkRequired: "N",
          documentOptionSequence: "undefined",
        })
      );
    });
    it("should handle axios.post rejection and call dispatchError", async () => {
      // Mock environment variables
      process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
      process.env.REACT_APP_RTOB_APPLICATION_END_POINT =
        "/application-endpoint/";
      process.env.REACT_APP_RTOB_DOCUMENTS_END_POINT = "/documents-endpoint/";

      const mockedError = new Error("mocked_error");
      mockedAxios.post.mockRejectedValueOnce(mockedError);

      const channelReference = "mocked_channel_ref";
      const file = new File(["dummy content"], "testDocument.pdf", {
        type: "application/pdf",
      });

      await expect(postDocuments(channelReference, file)).rejects.toThrow(
        "mocked_error"
      );

      expect(dispatchError).toHaveBeenCalledWith(mockedError);
    });
   });




export const postDocuments = (channelReference: any, file: any): any => {
  const imageOrder = JSON.parse(JSON.stringify(store.getState().preApproval.incomeProofDocumentUpload));
  
  console.log("store:----", store.getState())
  const documentJson: any = {
    origin: "front-line-supporting-document",
    documentCategoryCode: "R0005",
    documentTypeCode: "A023",
    applicantId: 1,
    imageOrder: imageOrder?.length + 1,
    period: 0,
    isWatermarkRequired: "Y",
    documentOptionSequence: "undefined",
  };

  console.log("----",  "imageOrder :",imageOrder);

  const baseUrl = `${process.env.REACT_APP_RTOB_BASE_URL}`;
  const endPoint = `${process.env.REACT_APP_RTOB_DOCUMENTS_END_POINT}`;
  const application = `${process.env.REACT_APP_RTOB_APPLICATION_END_POINT}`;

  const url = baseUrl + application + channelReference + endPoint;


  let data = new FormData();
  data.append("file", file);
  data.append("documentJson", JSON.stringify(documentJson));

  const options = {
    method: "POST",
    url,
    headers: {
      "Content-Type": "multipart/form-data",
      "Sc-Client-Context": PreApprovalUtil.getAckMetaData(channelReference),
    },
    body: JSON.stringify(data),
  };
const docaxios = axios.create({
    headers: options.headers,
  });

   return docaxios
   .post(url, data, options)
   .then((response: any) => {
          return Promise.resolve(response);
        })
        .catch((error: any) => {
          dispatchError(error);
          console.log("clientResponse", error);
          return Promise.reject(error);
        });

  }
