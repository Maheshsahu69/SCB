// Import necessary modules
import { nextStage } from './path-to-your-function'; // Adjust the path to your function file
import { 
    postTMXUserSession, 
    postFinalAcknowledge, 
    postDocSaveData 
} from './api'; // Mock these API calls
import { dispatchLoader, preApprovalAction, stagesAction } from './actions'; // Mock these actions
import { CONSTANTS, stageSelector } from './constants'; // Mock these constants

jest.mock('./api'); // Mock the API module
jest.mock('./actions'); // Mock actions
jest.mock('./constants', () => ({
    CONSTANTS: { STAGE_NAMES: { LD_1: 'LD_1' } },
    stageSelector: [{ stageInfo: { id: 'dummy-stage-info' } }],
}));

// Mock dispatch
const dispatch = jest.fn();

// Mock API responses
const mockPostTMXUserSession = {
    status: 200,
    data: { review_status: 'pass' },
};

const mockPostFinalAcknowledge = {
    status: 202,
};

const mockPostDocSaveData = {
    data: {
        applicants: [{ id: 1, name: 'John Doe' }],
        application: { id: 123, name: 'Test Application' },
        applicant_documents: [{ id: 'doc-1', type: 'passport' }],
    },
};

// Test suite
describe('nextStage function', () => {
    beforeEach(() => {
        jest.clearAllMocks();
    });

    it('should successfully complete the next stage process', async () => {
        // Mock the API calls
        postTMXUserSession.mockResolvedValue(mockPostTMXUserSession);
        postFinalAcknowledge.mockResolvedValue(mockPostFinalAcknowledge);
        postDocSaveData.mockResolvedValue(mockPostDocSaveData);

        // Call the function
        await nextStage();

        // Assertions for dispatchLoader
        expect(dispatch).toHaveBeenCalledWith(dispatchLoader(true));
        expect(dispatch).toHaveBeenCalledWith(dispatchLoader(false));

        // Assertions for postTMXUserSession
        expect(postTMXUserSession).toHaveBeenCalledWith('channel_reference');
        expect(postFinalAcknowledge).toHaveBeenCalledWith('channel_reference');

        // Assertions for postDocSaveData
        expect(postDocSaveData).toHaveBeenCalledWith(
            'documentData',
            'HKIDQRCodeData',
            'zolozDocumentData'
        );

        // Assertions for dispatching actions
        expect(dispatch).toHaveBeenCalledWith(preApprovalAction.setCurrentStage('PD-3'));
        expect(dispatch).toHaveBeenCalledWith(stagesAction.updateStageId(CONSTANTS.STAGE_NAMES.LD_1));

        // Assertions for stage data
        const expectedStageData = {
            applicants: mockPostDocSaveData.data.applicants,
            application: mockPostDocSaveData.data.application,
            applicant_documents: mockPostDocSaveData.data.applicant_documents,
        };

        expect(dispatch).toHaveBeenCalledWith(stagesAction.getStage({
            id: CONSTANTS.STAGE_NAMES.LD_1,
            formConfig: expectedStageData,
        }));
    });

    it('should skip processing if postTMXUserSession fails or review_status is not "pass"', async () => {
        // Mock a failed session response
        postTMXUserSession.mockResolvedValue({ status: 400 });

        // Call the function
        await nextStage();

        // Ensure further actions are not triggered
        expect(postFinalAcknowledge).not.toHaveBeenCalled();
        expect(postDocSaveData).not.toHaveBeenCalled();

        // Ensure dispatchLoader is called correctly
        expect(dispatch).toHaveBeenCalledWith(dispatchLoader(true));
        expect(dispatch).toHaveBeenCalledWith(dispatchLoader(false));
    });

    it('should skip processing if postFinalAcknowledge fails', async () => {
        // Mock responses
        postTMXUserSession.mockResolvedValue(mockPostTMXUserSession);
        postFinalAcknowledge.mockResolvedValue({ status: 400 });

        // Call the function
        await nextStage();

        // Ensure postDocSaveData is not called
        expect(postDocSaveData).not.toHaveBeenCalled();

        // Ensure dispatchLoader is called correctly
        expect(dispatch).toHaveBeenCalledWith(dispatchLoader(true));
        expect(dispatch).toHaveBeenCalledWith(dispatchLoader(false));
    });
});







import {
  postSaveData,
  postDocSaveData,
  postBasicData,
  postAditionalData,
  postDocuments,
  postQRCodeZOLO,
  postZOLOCheck,
  postZolozAcknowledge,
  postFinalAcknowledge,
  postPdfPreview,
  postTMXUserSession,
  postFulFilmentData,
} from "./preApprovalPostServices";
import axios from "axios";
import { store } from "../../../utils/store/store";
import { dispatchError } from "../../../services/common-service";
import PreApprovalUtil from "./preApprovalUtils";

jest.mock("./payload", () => ({
  adpayload: jest.fn(() => ({
    applicants: [],
    fieldmetadata: {},
    products: [],
    stage: {},
    status: {},
    applicant_documents: [],
    client: {},
    dedupe: {},
    dedupeList: [],
    etc_data: {},
    lov_desc: {},
    oz_templates: [],
    preApprovedData: {},
    preapproved: {
      incomeProofDocumentUploadP:[{}],
    },
    service_response: {},
  }
      
  )),
}));

jest.mock("axios");
const mockedAxios = axios as jest.Mocked<typeof axios>;
const mockDispatch = jest.fn();
jest.mock("../../../utils/store/store", () => ({
  store: {
    getState: jest.fn(),
  },
}));
jest.mock("axios", () => ({
  __esModule: true,
}));
jest.mock("../../../services/common-service", 
() => ({
  dispatchError: jest.fn(),
}));
jest.mock("./preApprovalUtils", () => ({
  getFormConfigPayload: jest.fn(() => ({ applicants: {}, application: {} })),
  getAckMetaData: jest.fn(() => "mocked_meta_data"),
  getADFormConfigPayload: jest.fn(),
  generateUUID: jest.fn(),
}));

jest.mock("axios", () => ({
  post: jest.fn(),
}));
describe("API Functions", () => {
  beforeEach(() => {
    (axios.post as jest.Mock).mockReset();

    (store.getState as jest.Mock).mockReturnValue({
      stages: {
        stages: [
          {
            stageInfo: {
              application: {
                channel_reference: "test_channel_ref",
                application_reference: "test_application_ref",
                applicatnt_documents: [
                  {
                    documentzoloCheckRes: "mocked_zolo_check_res",
                  },
                ],
              },
            },
            preApproval:{
              incomeProofDocumentUploadP:[{
                
              }]
            }
          },
        ],
      },
      preApproval: {
        documentZoloCheckRes: "mocked_documentZoloCheckRes",
      },
    });
  });
  afterEach(() => {
    jest.clearAllMocks();
  });

  test("should successfully call postSaveData and resolve", async () => {
    const mockedResponse = { data: "success" };
    mockedAxios.post = jest.fn().mockResolvedValue(mockedResponse);
    const result = await postSaveData();
    expect(result).toEqual(mockedResponse);
    expect(axios.post).toHaveBeenCalled();
  });
