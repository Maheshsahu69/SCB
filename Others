import { useEffect, useLayoutEffect, useRef, useState } from "react";
import "./dashboard.scss";
import Header from "./header/header";
import Fields from "./fields/fields";
import { useDispatch, useSelector } from "react-redux";
import { useLocation, useNavigate } from "react-router-dom";
import {
  dispatchLoader,
  getClientInfo,
} from "../../services/common-service";
import { StoreModel } from "../../utils/model/common-model";
import MyinfoSingpassLogin from "../../shared/components/myinfo-singpass-login-modal/myinfo-singpass-login";
import PopupModel from "../../shared/components/popup-model/popup-model";
import { urlParamAction } from "../../utils/store/urlparam-slice";
import Model from "../../shared/components/model/model";
import { loaderAction } from "../../utils/store/loader-slice";
import { store } from "../../utils/store/store";
import { getUrl } from "../../utils/common/change.utils";
const Dashboard = () => {
  const dispatch = useDispatch();
  const navigate = useNavigate();
  const urlParams = useLocation();
  const stageSelector = useSelector((state: StoreModel) => state.stages.stages);
  const myInfoAuthSelector = useSelector(
    (state: StoreModel) => state.urlParam.myInfo
  );
  const otpShowSelector = useSelector(
    (state: StoreModel) => state.stages.otpOpen
  );
  const otpResumeSelector = useSelector(
    (state: StoreModel) => state.stages.otpResume
  );
  const referralcodeSelector = useSelector((state: StoreModel) => state.referralcode);
  const [urlInvalid, setUrlInvalid] = useState(false);
  const [marginTop, setMarginTop] = useState(0);
  const headerHeight = useRef<HTMLInputElement>(null);
  const [fieldsComponent, setFieldsComponent] = useState(false);
  const [pointer, setPointer] = useState(false);
  const ctaLoader: any = getUrl.getLoader().cta;
  const [isMobileView, setIsMobileView] = useState<number>(0);
  const [uploadJourney, setFieldsUpload] = useState(false);
  const [ntcIbanking, setNtcIbanking] = useState(false);

  useEffect(() => {
    if (ctaLoader) {
      setPointer(ctaLoader.cta ? true : false);
    }
  }, [ctaLoader]);

  useLayoutEffect(() => {
    let clearSetTimeout: ReturnType<typeof setTimeout>;
    function updateSize() {
      setIsMobileView(window.innerWidth < 768 ? 110 : 167);
      if (headerHeight.current) {
        clearSetTimeout = setTimeout(() => {
          setMarginTop(headerHeight && headerHeight.current!["offsetHeight"]);
        }, 100);
      }
    }
    window.addEventListener("resize", updateSize);
    updateSize();
    return () => {
      window.removeEventListener("resize", updateSize);
      clearTimeout(clearSetTimeout);
    };
  }, [stageSelector]);

  
  useEffect(() => {
    dispatch(dispatchLoader(true));
    dispatch(urlParamAction.getUrlParameter(urlParams));
    if (!store.getState().urlParam.validUrl) {
      dispatch(
        loaderAction.getState({
          isFetching: false,
        })
      );
      setUrlInvalid(true);
    } 
   
    else {
      dispatch(getClientInfo()).then(async (response: any) => {
        if(response){
        setFieldsComponent(true);
        navigate("sg/super-short-form");
      }
     
      });
    }

    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
 
  return (
    <>
      {(urlInvalid || myInfoAuthSelector  || ntcIbanking) && (
        <PopupModel displayPopup={myInfoAuthSelector || urlInvalid  || ntcIbanking}>
          {urlInvalid ? <Model name="globalError" /> : <MyinfoSingpassLogin />}
        </PopupModel>
      )}

      {/* {stageSelector &&
        stageSelector[0] &&
        stageSelector[0].stageId === "bd-3" &&
        otpShowSelector && <OTPModel />} */}

      {stageSelector && stageSelector.length > 0 && !otpShowSelector && (
        <div className="app">
          <div className="app__header">
            <div ref={headerHeight}>
              <Header />
            </div>
          </div>
          <div
            className={`app__body ${pointer ? "pointer-none" : ""}`}
            style={{
              marginTop: marginTop + "px",
              height: `calc(100dvh - ${marginTop + isMobileView}px)`,
            }}
          >
            <div className="wrapper">
              <div>{fieldsComponent && <Fields />}</div>
              <div>{/* <NeedHelp /> */}</div>
            </div>
          </div>
        </div>
      )}
    </>
  );
};

export default Dashboard;







import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import Dashboard from "./dashboard";
import { Provider } from "react-redux";
import { store } from "../../utils/store/store";
import { MemoryRouter } from "react-router-dom";
import * as redux from "react-redux";
import { getClientInfo } from "../../services/common-service";
import { loaderAction } from "../../utils/store/loader-slice";

// Mock dependencies
jest.mock("../../services/common-service", () => ({
  getClientInfo: jest.fn(),
}));

jest.mock("react-router-dom", () => ({
  ...jest.requireActual("react-router-dom"),
  useNavigate: jest.fn(),
  useLocation: jest.fn(() => ({
    pathname: "/dashboard",
  })),
}));

// Helper function for rendering component with Redux and Router
const renderComponent = () => {
  return render(
    <Provider store={store}>
      <MemoryRouter>
        <Dashboard />
      </MemoryRouter>
    </Provider>
  );
};

describe("Dashboard Component", () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  test("renders the Dashboard component", () => {
    renderComponent();
    expect(screen.getByRole("heading", { name: /dashboard/i })).toBeInTheDocument();
  });

  test("dispatches actions on mount", async () => {
    const dispatchMock = jest.spyOn(redux, "useDispatch");
    const mockDispatch = jest.fn();
    dispatchMock.mockReturnValue(mockDispatch);

    renderComponent();

    await waitFor(() => {
      expect(mockDispatch).toHaveBeenCalledWith(loaderAction.getState({ isFetching: false }));
      expect(mockDispatch).toHaveBeenCalledWith(expect.any(Function)); // Mocked async action
    });
  });

  test("calls getClientInfo on mount", async () => {
    (getClientInfo as jest.Mock).mockResolvedValueOnce({ data: "mockData" });

    renderComponent();

    await waitFor(() => {
      expect(getClientInfo).toHaveBeenCalledTimes(1);
    });
  });

  test("renders the Header component", () => {
    renderComponent();
    expect(screen.getByRole("banner")).toBeInTheDocument();
  });

  test("renders Fields component when conditions are met", async () => {
    (getClientInfo as jest.Mock).mockResolvedValueOnce({ data: "mockData" });

    renderComponent();

    await waitFor(() => {
      expect(screen.getByTestId("fields-component")).toBeInTheDocument();
    });
  });

  test("handles window resize event correctly", async () => {
    renderComponent();

    fireEvent.resize(window, { target: { innerWidth: 500 } });

    await waitFor(() => {
      expect(window.innerWidth).toBe(500);
    });
  });

  test("renders popup modal when url is invalid", async () => {
    (getClientInfo as jest.Mock).mockResolvedValueOnce(null);

    renderComponent();

    await waitFor(() => {
      expect(screen.getByTestId("popup-modal")).toBeInTheDocument();
    });
  });

  test("calls navigation function on success", async () => {
    const mockNavigate = jest.fn();
    jest.spyOn(require("react-router-dom"), "useNavigate").mockReturnValue(mockNavigate);

    (getClientInfo as jest.Mock).mockResolvedValueOnce({});

    renderComponent();

    await waitFor(() => {
      expect(mockNavigate).toHaveBeenCalledWith("sg/super-short-form");
    });
  });
});
