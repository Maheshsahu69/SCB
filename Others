test("should call getOffer2 and resolve with response", async () => {
  // Mock the state
  jest.spyOn(store, "getState").mockReturnValue({
    stages: {
      stages: [
        {
          stageId: "mockStageId",
          stageInfo: {
            application: {
              channel_reference: "mockChannelRef",
            },
            products: [
              {
                product_type: "mockProductType",
              },
            ],
          },
        },
      ],
    },
  });

  const mockPayload = { someKey: "someValue" };
  const mockResponse = { data: { offerDetails: "mockOfferDetails" }, status: 200 };

  mockedAxios.post.mockResolvedValue(mockResponse);

  const result = await getOffer2(mockPayload);

  // Assertions
  expect(result).toEqual(mockResponse);
  expect(mockedAxios.post).toHaveBeenCalledWith(
    expect.stringContaining("mockChannelRef"), // Ensure the correct endpoint is used
    JSON.stringify({
      ...mockPayload,
      stage: {
        page_id: "mockStageId",
        stage_id: "MOCKSTAGEID",
        stage_status: "incomplete",
      },
      applicants: expect.any(Object), // Ensure applicants field is present
      client: expect.any(Object), // Ensure client field is present
    }),
    expect.objectContaining({
      headers: expect.objectContaining({
        "Content-Type": "application/json;charset=UTF-8",
      }),
    })
  );
});

test("should handle error in getOffer2", async () => {
  // Mock the state
  jest.spyOn(store, "getState").mockReturnValue({
    stages: {
      stages: [
        {
          stageId: "mockStageId",
          stageInfo: {
            application: {
              channel_reference: "mockChannelRef",
            },
          },
        },
      ],
    },
  });

  const mockPayload = { someKey: "someValue" };
  const mockError = new Error("Offer2 API error");

  mockedAxios.post.mockRejectedValue(mockError);

  await expect(getOffer2(mockPayload)).rejects.toThrow("Offer2 API error");

  // Ensure dispatchError is called
  expect(commonService.dispatchError).toHaveBeenCalledWith(mockError);
});


test("should call getOfferCalulated and resolve with response", async () => {
  // Mock the state
  jest.spyOn(store, "getState").mockReturnValue({
    stages: {
      stages: [
        {
          stageInfo: {
            application: {
              channel_reference: "mockChannelRef",
              cos_ref_number: "mockCosRef",
              application_reference: "mockAppRef",
            },
          },
        },
      ],
    },
  });

  const mockData = {
    requested_amount: 10000,
    requested_tenure: 12,
  };
  const mockResponse = { data: { calculatedOffer: "mockCalculatedOffer" }, status: 200 };

  mockedAxios.post.mockResolvedValue(mockResponse);

  const result = await getOfferCalulated(mockData);

  // Assertions
  expect(result).toEqual(mockResponse);
  expect(mockedAxios.post).toHaveBeenCalledWith(
    expect.stringContaining("mockChannelRef"), // Ensure the correct endpoint is used
    JSON.stringify({
      channel_ref_number: "mockChannelRef",
      cos_ref_number: "mockCosRef",
      application_reference: "mockAppRef",
      source_system_name: "02",
      requested_amount: 10000,
      requested_tenure: 12,
    }),
    expect.objectContaining({
      headers: expect.objectContaining({
        "Content-Type": "application/json;charset=UTF-8",
      }),
    })
  );
});



test("should handle error in getOfferCalulated", async () => {
  // Mock the state
  jest.spyOn(store, "getState").mockReturnValue({
    stages: {
      stages: [
        {
          stageInfo: {
            application: {
              channel_reference: "mockChannelRef",
              cos_ref_number: "mockCosRef",
              application_reference: "mockAppRef",
            },
          },
        },
      ],
    },
  });

  const mockData = {
    requested_amount: 10000,
    requested_tenure: 12,
  };
  const mockError = new Error("OfferCalulated API error");

  mockedAxios.post.mockRejectedValue(mockError);

  await expect(getOfferCalulated(mockData)).rejects.toThrow("OfferCalulated API error");

  // Ensure dispatchError is called
  expect(commonService.dispatchError).toHaveBeenCalledWith(mockError);
});



import { postBasicData } from "./yourFile";
import axios from "axios";
import { store } from "../../../utils/store/store";
import PreApprovalUtil from "./preApprovalUtils";
import { dispatchError } from "../../../services/common-service";

jest.mock("axios"); // Mock axios globally
jest.mock("../../../utils/store/store", () => ({
  store: {
    getState: jest.fn(),
  },
}));
jest.mock("./preApprovalUtils", () => ({
  getFormConfigPayload: jest.fn(),
  getAckMetaData: jest.fn(),
}));
jest.mock("../../../services/common-service", () => ({
  dispatchError: jest.fn(),
}));

const mockedAxios = axios as jest.Mocked<typeof axios>;

describe("postBasicData", () => {
  beforeEach(() => {
    mockedAxios.post.mockReset();
    (store.getState as jest.Mock).mockReturnValue({
      stages: {
        stages: [
          {
            stageInfo: {
              application: {
                channel_reference: "mocked_channel_ref",
              },
            },
          },
        ],
      },
    });

    PreApprovalUtil.getFormConfigPayload.mockReturnValue({
      applicants: {},
      application: {},
    });

    PreApprovalUtil.getAckMetaData.mockReturnValue("mocked_ack_meta_data");
  });

  it("should call axios.post with correct arguments and resolve", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_BASIC_DATA_END_POINT = "/basic-data-endpoint/";

    const mockedResponse = { data: "mocked_response" };
    mockedAxios.post.mockResolvedValueOnce(mockedResponse);

    const result = await postBasicData();

    const expectedUrl =
      "https://mock-base-url/application-endpoint/mocked_channel_ref/basic-data-endpoint/";
    const expectedHeaders = {
      "Content-Type": "application/json;charset=UTF-8",
      "Sc-Client-Context": "mocked_ack_meta_data",
    };
    const expectedPayload = JSON.stringify({
      applicants: {},
      application: {},
    });

    expect(mockedAxios.post).toHaveBeenCalledWith(expectedUrl, expectedPayload, {
      headers: expectedHeaders,
    });
    expect(result).toEqual(mockedResponse);
  });

  it("should handle axios.post rejection and call dispatchError", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_BASIC_DATA_END_POINT = "/basic-data-endpoint/";

    const mockedError = new Error("mocked_error");
    mockedAxios.post.mockRejectedValueOnce(mockedError);

    await expect(postBasicData()).rejects.toThrow("mocked_error");

    expect(dispatchError).toHaveBeenCalledWith(mockedError);
  });
});

import { postZOLOCheck } from "./yourFile";
import axios from "axios";
import { store } from "../../../utils/store/store";
import PreApprovalUtil from "./preApprovalUtils";
import { dispatchError } from "../../../services/common-service";

jest.mock("axios");
jest.mock("../../../utils/store/store", () => ({
  store: {
    getState: jest.fn(),
  },
}));
jest.mock("./preApprovalUtils", () => ({
  getAckMetaData: jest.fn(),
}));
jest.mock("../../../services/common-service", () => ({
  dispatchError: jest.fn(),
}));

const mockedAxios = axios as jest.Mocked<typeof axios>;

describe("postZOLOCheck", () => {
  beforeEach(() => {
    mockedAxios.post.mockReset();
    (store.getState as jest.Mock).mockReturnValue({
      stages: {
        stages: [
          {
            stageInfo: {
              applicants: {
                first_name_a_1: "John",
                last_name_a_1: "Doe",
                date_of_birth_a_1: "1990-01-01",
                HKID_a_1: "A1234567",
                product_type: "CreditCard",
                product_category: "Platinum",
              },
              application: {
                cos_ref_number: "COS123456",
              },
            },
          },
        ],
      },
    });

    PreApprovalUtil.getAckMetaData.mockReturnValue("mocked_ack_meta_data");
  });

  it("should call axios.post with correct arguments and resolve", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_ZOLO_CHECK_RESULT_END_POINT = "/zolo-check-endpoint/";

    const mockedResponse = { data: "mocked_response" };
    mockedAxios.post.mockResolvedValueOnce(mockedResponse);

    const channelReference = "mocked_channel_ref";
    const transactionId = "txn123456";
    const docType = "HKID";

    const result = await postZOLOCheck(channelReference, transactionId, docType);

    const expectedUrl = "https://mock-base-url/application-endpoint/mocked_channel_ref/zolo-check-endpoint/";
    const expectedPayload = {
      transactionId: "txn123456",
      isReturnImage: "Y",
      first_name_a_1: "John",
      last_name_a_1: "Doe",
      date_of_birth_a_1: "1990-01-01",
      HKID_a_1: "A1234567",
      product_type: "CreditCard",
      product_category: "Platinum",
      hkid_type: "HKID",
      cos_ref_number: "COS123456",
    };
    const expectedHeaders = {
      "Content-Type": "application/json;charset=UTF-8",
      "Sc-Client-Context": "mocked_ack_meta_data",
    };

    expect(mockedAxios.post).toHaveBeenCalledWith(expectedUrl, JSON.stringify(expectedPayload), {
      headers: expectedHeaders,
    });
    expect(result).toEqual(mockedResponse);
  });

  it("should handle axios.post rejection and call dispatchError", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_ZOLO_CHECK_RESULT_END_POINT = "/zolo-check-endpoint/";

    const mockedError = new Error("mocked_error");
    mockedAxios.post.mockRejectedValueOnce(mockedError);

    const channelReference = "mocked_channel_ref";
    const transactionId = "txn123456";
    const docType = "HKID";

    await expect(postZOLOCheck(channelReference, transactionId, docType)).rejects.toThrow(
      "mocked_error"
    );

    expect(dispatchError).toHaveBeenCalledWith(mockedError);
  });
});


import { postZoloAcknowledge } from "./yourFile";
import axios from "axios";
import { store } from "../../../utils/store/store";
import PreApprovalUtil from "./preApprovalUtils";
import { dispatchError } from "../../../services/common-service";

jest.mock("axios");
jest.mock("../../../utils/store/store", () => ({
  store: {
    getState: jest.fn(),
  },
}));
jest.mock("./preApprovalUtils", () => ({
  getAckMetaData: jest.fn(),
}));
jest.mock("../../../services/common-service", () => ({
  dispatchError: jest.fn(),
}));

const mockedAxios = axios as jest.Mocked<typeof axios>;

describe("postZoloAcknowledge", () => {
  beforeEach(() => {
    mockedAxios.post.mockReset();
    (store.getState as jest.Mock).mockReturnValue({
      stages: {
        stages: [
          {
            stageInfo: {
              application: {
                channel_reference: "mocked_channel_ref",
                application_reference: "mocked_application_ref",
              },
            },
          },
        ],
      },
    });

    PreApprovalUtil.getAckMetaData.mockReturnValue("mocked_ack_meta_data");
  });

  it("should call axios.post with correct arguments and resolve", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_DOCUMENTS_END_POINT = "/documents-endpoint/";
    process.env.REACT_APP_RTOB_ACKNOWLEDGE_END_POINT = "/acknowledge-endpoint/";

    const mockedResponse = { data: "mocked_response" };
    mockedAxios.post.mockResolvedValueOnce(mockedResponse);

    const channelReference = "mocked_channel_ref";
    const documentsList = [
      {
        docId: "doc123",
        documentName: "testDocument.pdf",
        documentStatus: "Accepted",
      },
    ];

    const result = await postZoloAcknowledge(channelReference, documentsList);

    const expectedUrl =
      "https://mock-base-url/application-endpoint/mocked_channel_ref/documents-endpoint/acknowledge-endpoint/";
    const expectedPayload = {
      applicationRefNo: "mocked_application_ref",
      documents: documentsList,
      optionsSelected: [
        {
          applicantId: 1,
          options: [
            {
              documentCategoryCode: "R0001",
              documentTypeCode: "A001",
              documentOptionSequence: "1",
            },
          ],
        },
      ],
      stage: "Zoloz_ACK",
    };
    const expectedHeaders = {
      "Content-Type": "application/json;charset=UTF-8",
      "Sc-Client-Context": "mocked_ack_meta_data",
    };

    expect(mockedAxios.post).toHaveBeenCalledWith(expectedUrl, JSON.stringify(expectedPayload), {
      headers: expectedHeaders,
    });
    expect(result).toEqual(mockedResponse);
  });

  it("should handle axios.post rejection and call dispatchError", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_DOCUMENTS_END_POINT = "/documents-endpoint/";
    process.env.REACT_APP_RTOB_ACKNOWLEDGE_END_POINT = "/acknowledge-endpoint/";

    const mockedError = new Error("mocked_error");
    mockedAxios.post.mockRejectedValueOnce(mockedError);

    const channelReference = "mocked_channel_ref";
    const documentsList = [
      {
        docId: "doc123",
        documentName: "testDocument.pdf",
        documentStatus: "Accepted",
      },
    ];

    await expect(postZoloAcknowledge(channelReference, documentsList)).rejects.toThrow(
      "mocked_error"
    );

    expect(dispatchError).toHaveBeenCalledWith(mockedError);
  });
});

import { postFinalAcknowledge } from "./yourFile";
import axios from "axios";
import { store } from "../../../utils/store/store";
import PreApprovalUtil from "./preApprovalUtils";
import { dispatchError } from "../../../services/common-service";

jest.mock("axios");
jest.mock("../../../utils/store/store", () => ({
  store: {
    getState: jest.fn(),
  },
}));
jest.mock("./preApprovalUtils", () => ({
  getAckMetaData: jest.fn(),
}));
jest.mock("../../../services/common-service", () => ({
  dispatchError: jest.fn(),
}));

const mockedAxios = axios as jest.Mocked<typeof axios>;

describe("postFinalAcknowledge", () => {
  beforeEach(() => {
    mockedAxios.post.mockReset();
    (store.getState as jest.Mock).mockReturnValue({
      stages: {
        stages: [
          {
            stageInfo: {
              application: {
                channel_reference: "mocked_channel_ref",
                application_reference: "mocked_application_ref",
              },
            },
          },
        ],
      },
    });

    PreApprovalUtil.getAckMetaData.mockReturnValue("mocked_ack_meta_data");
  });

  it("should call axios.post with correct arguments and resolve", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_DOCUMENTS_END_POINT = "/documents-endpoint/";
    process.env.REACT_APP_RTOB_ACKNOWLEDGE_END_POINT = "/acknowledge-endpoint/";

    const mockedResponse = { data: "mocked_response" };
    mockedAxios.post.mockResolvedValueOnce(mockedResponse);

    const channelReference = "mocked_channel_ref";

    const result = await postFinalAcknowledge(channelReference);

    const expectedUrl =
      "https://mock-base-url/application-endpoint/mocked_channel_ref/documents-endpoint/acknowledge-endpoint/";
    const expectedPayload = {
      applicationRefNo: "mocked_application_ref",
      documents: [],
      optionsSelected: [
        {
          applicantId: 1,
          options: [],
        },
      ],
      stage: "Final_ACK",
    };
    const expectedHeaders = {
      "Content-Type": "application/json;charset=UTF-8",
      "Sc-Client-Context": "mocked_ack_meta_data",
    };

    expect(mockedAxios.post).toHaveBeenCalledWith(expectedUrl, JSON.stringify(expectedPayload), {
      headers: expectedHeaders,
    });
    expect(result).toEqual(mockedResponse);
  });

  it("should handle axios.post rejection and call dispatchError", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_DOCUMENTS_END_POINT = "/documents-endpoint/";
    process.env.REACT_APP_RTOB_ACKNOWLEDGE_END_POINT = "/acknowledge-endpoint/";

    const mockedError = new Error("mocked_error");
    mockedAxios.post.mockRejectedValueOnce(mockedError);

    const channelReference = "mocked_channel_ref";

    await expect(postFinalAcknowledge(channelReference)).rejects.toThrow("mocked_error");

    expect(dispatchError).toHaveBeenCalledWith(mockedError);
  });
});



import { postQRCodeZOLO } from "./yourFile";
import axios from "axios";
import PreApprovalUtil from "./preApprovalUtils";
import { dispatchError } from "../../../services/common-service";

jest.mock("axios");
jest.mock("./preApprovalUtils", () => ({
  getAckMetaData: jest.fn(),
}));
jest.mock("../../../services/common-service", () => ({
  dispatchError: jest.fn(),
}));

const mockedAxios = axios as jest.Mocked<typeof axios>;

describe("postQRCodeZOLO", () => {
  beforeEach(() => {
    mockedAxios.post.mockReset();
    PreApprovalUtil.getAckMetaData.mockReturnValue("mocked_ack_meta_data");
  });

  it("should call axios.post with correct arguments and resolve", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_QRCODE_SMART_HKID_END_POINT = "/qrcode-endpoint/";

    const mockedResponse = { data: "mocked_response" };
    mockedAxios.post.mockResolvedValueOnce(mockedResponse);

    const channelReference = "mocked_channel_ref";
    const docType = "HKID";

    const result = await postQRCodeZOLO(channelReference, docType);

    const expectedUrl =
      "https://mock-base-url/application-endpoint/mocked_channel_ref/qrcode-endpoint/";
    const expectedPayload = {
      docType: "HKID",
      qrCodeFlag: "Y",
      h5ModeConfig: {
        completeCallbackUrl:
          "https://pt.sc.com/onboarding/hk/zolozThankYou.html?scbToken=mocked_channel_ref&lang=en",
        interruptCallbackUrl:
          "https://pt.sc.com/onboarding/hk/zoloz-error.html?scbToken=mocked_channel_ref&lang=en",
        locale: "",
      },
    };
    const expectedHeaders = {
      "Content-Type": "application/json;charset=UTF-8",
      "Sc-Client-Context": "mocked_ack_meta_data",
    };

    expect(mockedAxios.post).toHaveBeenCalledWith(expectedUrl, JSON.stringify(expectedPayload), {
      headers: expectedHeaders,
    });
    expect(result).toEqual(mockedResponse);
  });

  it("should handle axios.post rejection and call dispatchError", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_QRCODE_SMART_HKID_END_POINT = "/qrcode-endpoint/";

    const mockedError = new Error("mocked_error");
    mockedAxios.post.mockRejectedValueOnce(mockedError);

    const channelReference = "mocked_channel_ref";
    const docType = "HKID";

    await expect(postQRCodeZOLO(channelReference, docType)).rejects.toThrow("mocked_error");

   

import { postPdfPreview } from "./yourFile";
import axios from "axios";
import { store } from "../../../utils/store/store";
import PreApprovalUtil from "./preApprovalUtils";
import { dispatchError } from "../../../services/common-service";

jest.mock("axios");
jest.mock("../../../utils/store/store", () => ({
  store: {
    getState: jest.fn(),
  },
}));
jest.mock("./preApprovalUtils", () => ({
  getAckMetaData: jest.fn(),
}));
jest.mock("../../../services/common-service", () => ({
  dispatchError: jest.fn(),
}));

const mockedAxios = axios as jest.Mocked<typeof axios>;

describe("postPdfPreview", () => {
  beforeEach(() => {
    mockedAxios.post.mockReset();
    (store.getState as jest.Mock).mockReturnValue({
      stages: {
        stages: [
          {
            stageInfo: {
              application: {
                channel_reference: "mocked_channel_ref",
                application_reference: "mocked_application_ref",
              },
            },
          },
        ],
      },
    });

    PreApprovalUtil.getAckMetaData.mockReturnValue("mocked_ack_meta_data");
  });

  it("should call axios.post with correct arguments and resolve", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_DYNAMIC_DOCUMENT = "/dynamic-doc/";
    process.env.REACT_APP_RTOB_PDF_PREVIEW = "/pdf-preview/";

    const mockedResponse = { data: "mocked_response" };
    mockedAxios.post.mockResolvedValueOnce(mockedResponse);

    const channelReference = "mocked_channel_ref";

    const result = await postPdfPreview(channelReference);

    const expectedUrl = "https://mock-base-url/dynamic-doc/mocked_channel_ref/pdf-preview/";
    const expectedPayload = {
      appInRefNumber: "mocked_application_ref",
      template_name: "ekyc_report",
      action: "generate",
      page_id: "HK_ALIPAY_AOF_ENG.thy",
    };
    const expectedHeaders = {
      "Content-Type": "application/json;charset=UTF-8",
      "Sc-Client-Context": "mocked_ack_meta_data",
    };

    expect(mockedAxios.post).toHaveBeenCalledWith(expectedUrl, JSON.stringify(expectedPayload), {
      headers: expectedHeaders,
    });
    expect(result).toEqual(mockedResponse);
  });

  it("should handle axios.post rejection and call dispatchError", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_DYNAMIC_DOCUMENT = "/dynamic-doc/";
    process.env.REACT_APP_RTOB_PDF_PREVIEW = "/pdf-preview/";

    const mockedError = new Error("mocked_error");
    mockedAxios.post.mockRejectedValueOnce(mockedError);

    const channelReference = "mocked_channel_ref";

    await expect(postPdfPreview(channelReference)).rejects.toThrow("mocked_error");

    expect(dispatchError).toHaveBeenCalledWith(mockedError);
  });
});

import { postTMXUserSession } from "./yourFile";
import axios from "axios";
import { store } from "../../../utils/store/store";
import PreApprovalUtil from "./preApprovalUtils";
import { dispatchError } from "../../../services/common-service";

jest.mock("axios");
jest.mock("../../../utils/store/store", () => ({
  store: {
    getState: jest.fn(),
  },
}));
jest.mock("./preApprovalUtils", () => ({
  getAckMetaData: jest.fn(),
}));
jest.mock("../../../services/common-service", () => ({
  dispatchError: jest.fn(),
}));

const mockedAxios = axios as jest.Mocked<typeof axios>;

describe("postTMXUserSession", () => {
  beforeEach(() => {
    mockedAxios.post.mockReset();
    (store.getState as jest.Mock).mockReturnValue({
      stages: {
        stages: [
          {
            stageInfo: {
              application: {
                cos_ref_number: "mocked_cos_ref_number",
              },
            },
          },
        ],
      },
    });

    PreApprovalUtil.getAckMetaData.mockReturnValue("mocked_ack_meta_data");
  });

  it("should call axios.post with correct arguments and resolve", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_VERIFY_TMX_USER_SESSION = "/tmx-session/";

    const mockedResponse = { data: "mocked_response" };
    mockedAxios.post.mockResolvedValueOnce(mockedResponse);

    const channelReference = "mocked_channel_ref";

    const result = await postTMXUserSession(channelReference);

    const expectedUrl = "https://mock-base-url/application-endpoint/mocked_channel_ref/tmx-session/";
    const expectedPayload = {
      session_id_tmx: "0e741a59-94e9-4603-b3fd-b0139e14583d",
      cos_ref_number: "mocked_cos_ref_number",
    };
    const expectedHeaders = {
      "Content-Type": "application/json;charset=UTF-8",
      "Sc-Client-Context": "mocked_ack_meta_data",
    };

    expect(mockedAxios.post).toHaveBeenCalledWith(expectedUrl, JSON.stringify(expectedPayload), {
      headers: expectedHeaders,
    });
    expect(result).toEqual(mockedResponse);
  });

  it("should handle axios.post rejection and call dispatchError", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_VERIFY_TMX_USER_SESSION = "/tmx-session/";

    const mockedError = new Error("mocked_error");
    mockedAxios.post.mockRejectedValueOnce(mockedError);

    const channelReference = "mocked_channel_ref";

    await expect(postTMXUserSession(channelReference)).rejects.toThrow("mocked_error");

    expect(dispatchError).toHaveBeenCalledWith(mockedError);
  });
});




import { postFulFilmentData } from "./yourFile";
import axios from "axios";
import { store } from "../../../utils/store/store";
import PreApprovalUtil from "./preApprovalUtils";
import { dispatchError } from "../../../services/common-service";

jest.mock("axios");
jest.mock("../../../utils/store/store", () => ({
  store: {
    getState: jest.fn(),
  },
}));
jest.mock("./preApprovalUtils", () => ({
  getAckMetaData: jest.fn(),
}));
jest.mock("../../../services/common-service", () => ({
  dispatchError: jest.fn(),
}));

const mockedAxios = axios as jest.Mocked<typeof axios>;

describe("postFulFilmentData", () => {
  beforeEach(() => {
    mockedAxios.post.mockReset();
    (store.getState as jest.Mock).mockReturnValue({
      stages: {
        stages: [
          {
            stageInfo: {
              application: {
                channel_reference: "mocked_channel_ref",
              },
            },
            stageId: "stage-id-1",
          },
        ],
      },
    });

    PreApprovalUtil.getAckMetaData.mockReturnValue("mocked_ack_meta_data");
  });

  it("should call axios.post with correct arguments and resolve", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_FULFILMENT_DATA = "/fulfilment-data/";

    const mockedResponse = { data: "mocked_response" };
    mockedAxios.post.mockResolvedValueOnce(mockedResponse);

    const payload = {
      applicants: [{ id: "applicant-id-1" }],
      application: { id: "application-id-1" },
      stage: {},
    };

    const result = await postFulFilmentData(payload);

    const expectedUrl =
      "https://mock-base-url/application-endpoint/mocked_channel_ref/fulfilment-data/";
    const expectedHeaders = {
      "Content-Type": "application/json;charset=UTF-8",
      "Sc-Client-Context": "mocked_ack_meta_data",
    };

    const expectedPayload = JSON.stringify({
      ...payload,
      stage: {
        page_id: "stage-id-1",
        workflow_stage_id: "STAGE",
        stage_id: "STAGEID1",
        stage_status: "incomplete",
        stage_params: {
          is_dedupe_required: false,
          current_applicant: 0,
          eb_status: null,
        },
      },
      status_data: null,
      preapproved: null,
      temp_login_data: null,
      service_response: null,
      application: {
        ...payload.application,
        service_type: "STAGEID1",
        alipay_ref_number: null,
        ext_acceptance_reference_number: null,
        ext_authentication_reference_number: null,
        stage_wise: null,
        version: null,
        source_system_name: "3",
        page_wise: null,
      },
      client: {
        journey: "prelogin_ntc_or_ntp",
        auth_type: "manual",
        login_type: "prelogin",
      },
    });

    expect(mockedAxios.post).toHaveBeenCalledWith(expectedUrl, expectedPayload, {
      headers: expectedHeaders,
    });
    expect(result).toEqual(mockedResponse);
  });

  it("should handle axios.post rejection and call dispatchError", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_FULFILMENT_DATA = "/fulfilment-data/";

    const mockedError = new Error("mocked_error");
    mockedAxios.post.mockRejectedValueOnce(mockedError);

    const payload = {
      applicants: [{ id: "applicant-id-1" }],
      application: { id: "application-id-1" },
      stage: {},
    };

    await expect(postFulFilmentData(payload)).rejects.toThrow("mocked_error");

    expect(dispatchError).toHaveBeenCalledWith(mockedError);
  });




import { postAditionalData } from "./yourFile";
import axios from "axios";
import { store } from "../../../utils/store/store";
import PreApprovalUtil from "./preApprovalUtils";
import { dispatchError } from "../../../services/common-service";
import { adpayload } from "./payload";

jest.mock("axios");
jest.mock("../../../utils/store/store", () => ({
  store: {
    getState: jest.fn(),
  },
}));
jest.mock("./preApprovalUtils", () => ({
  getAckMetaData: jest.fn(),
  getFormConfigPayload: jest.fn(),
}));
jest.mock("../../../services/common-service", () => ({
  dispatchError: jest.fn(),
}));
jest.mock("./payload", () => ({
  adpayload: jest.fn(() => ({
    applicants: [],
    fieldmetadata: {},
    products: [],
    stage: {},
    status: {},
    applicant_documents: [],
    client: {},
    dedupe: {},
    dedupeList: [],
    etc_data: {},
    lov_desc: {},
    oz_templates: [],
    preApprovedData: {},
    preapproved: {},
    service_response: {},
  })),
}));

const mockedAxios = axios as jest.Mocked<typeof axios>;

describe("postAditionalData", () => {
  beforeEach(() => {
    mockedAxios.post.mockReset();
    (store.getState as jest.Mock).mockReturnValue({
      stages: {
        stages: [
          {
            stageInfo: {
              application: {
                channel_reference: "mocked_channel_ref",
              },
            },
          },
        ],
      },
    });

    PreApprovalUtil.getAckMetaData.mockReturnValue("mocked_ack_meta_data");
    PreApprovalUtil.getFormConfigPayload.mockReturnValue({
      applicants: [{ id: "applicant-id" }],
      fieldmetadata: {},
      products: [],
      stage: {},
      status: {},
      applicant_documents: [],
      client: {},
      dedupe: {},
      dedupeList: [],
      etc_data: {},
      lov_desc: {},
      oz_templates: [],
      preApprovedData: {},
      preapproved: {},
      service_response: {},
    });
  });

  it("should call axios.post with correct arguments and resolve", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_ADDITIONAL_DATA_END_POINT = "/additional-data/";

    const mockedResponse = { data: "mocked_response" };
    mockedAxios.post.mockResolvedValueOnce(mockedResponse);

    const result = await postAditionalData();

    const expectedUrl =
      "https://mock-base-url/application-endpoint/mocked_channel_ref/additional-data/";
    const currentStageData = PreApprovalUtil.getFormConfigPayload();
    const expectedPayload = {
      ...adpayload(),
      applicants: currentStageData.applicants,
      fieldmetadata: currentStageData.fieldmetadata,
      products: currentStageData.products,
      stage: currentStageData.stage,
      status: currentStageData.status,
      applicant_documents: currentStageData.applicant_documents,
      client: currentStageData.client,
      dedupe: currentStageData.dedupe,
      dedupeList: currentStageData.dedupeList,
      etc_data: currentStageData.etc_data,
      lov_desc: currentStageData.lov_desc,
      oz_templates: currentStageData.oz_templates,
      preApprovedData: currentStageData.preApprovedData,
      preapproved: currentStageData.preapproved,
      service_response: currentStageData.service_response,
    };
    const expectedHeaders = {
      "Content-Type": "application/json;charset=UTF-8",
      "Sc-Client-Context": "mocked_ack_meta_data",
    };

    expect(mockedAxios.post).toHaveBeenCalledWith(expectedUrl, JSON.stringify(expectedPayload), {
      headers: expectedHeaders,
    });
    expect(result).toEqual(mockedResponse);
  });

  it("should handle axios.post rejection and call dispatchError", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_ADDITIONAL_DATA_END_POINT = "/additional-data/";

    const mockedError = new Error("mocked_error");
    mockedAxios.post.mockRejectedValueOnce(mockedError);

    await expect(postAditionalData()).rejects.toThrow("mocked_error");

    expect(dispatchError).toHaveBeenCalledWith(mockedError);
  });
});
});



import { postDocumemts } from "./yourFile";
import axios from "axios";
import PreApprovalUtil from "./preApprovalUtils";
import { dispatchError } from "../../../services/common-service";

jest.mock("axios");
jest.mock("./preApprovalUtils", () => ({
  getAckMetaData: jest.fn(),
}));
jest.mock("../../../services/common-service", () => ({
  dispatchError: jest.fn(),
}));

const mockedAxios = axios as jest.Mocked<typeof axios>;

describe("postDocumemts", () => {
  beforeEach(() => {
    mockedAxios.post.mockReset();
    PreApprovalUtil.getAckMetaData.mockReturnValue("mocked_ack_meta_data");
  });

  it("should call axios.post with correct arguments and resolve", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_DOCUMENTS_END_POINT = "/documents-endpoint/";

    const mockedResponse = { data: "mocked_response" };
    mockedAxios.post.mockResolvedValueOnce(mockedResponse);

    const channelReference = "mocked_channel_ref";
    const file = new File(["dummy content"], "testDocument.pdf", { type: "application/pdf" });

    const result = await postDocumemts(channelReference, file);

    const expectedUrl =
      "https://mock-base-url/application-endpoint/mocked_channel_ref/documents-endpoint/";

    // Check that the `axios.post` is called with a FormData object
    expect(mockedAxios.post).toHaveBeenCalledWith(expectedUrl, expect.any(FormData), {
      headers: {
        "Content-Type": "multipart/form-data",
        "Sc-Client-Context": "mocked_ack_meta_data",
      },
    });

    // Ensure the result matches the mocked response
    expect(result).toEqual(mockedResponse);

    // Check FormData contents
    const formData = new FormData();
    formData.append("file", file, "testDocument.pdf");
    formData.append(
      "documentJson",
      JSON.stringify({
        origin: "front-line-supporting-document",
        documentCategoryCode: "R0005",
        documentTypeCode: "A023",
        applicantId: 1,
        imageOrder: 5,
        period: 0,
        isWatermarkRequired: "N",
        documentOptionSequence: "undefined",
      })
    );
  });

  it("should handle axios.post rejection and call dispatchError", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_DOCUMENTS_END_POINT = "/documents-endpoint/";

    const mockedError = new Error("mocked_error");
    mockedAxios.post.mockRejectedValueOnce(mockedError);

    const channelReference = "mocked_channel_ref";
    const file = new File(["dummy content"], "testDocument.pdf", { type: "application/pdf" });

    await expect(postDocumemts(channelReference, file)).rejects.toThrow("mocked_error");

    expect(dispatchError).toHaveBeenCalledWith(mockedError);
  });
});

import { postBasicData } from "./yourFile";
import axios from "axios";
import { store } from "../../../utils/store/store";
import PreApprovalUtil from "./preApprovalUtils";
import { dispatchError } from "../../../services/common-service";

jest.mock("axios");
jest.mock("../../../utils/store/store", () => ({
  store: {
    getState: jest.fn(),
  },
}));
jest.mock("./preApprovalUtils", () => ({
  getFormConfigPayload: jest.fn(),
  getAckMetaData: jest.fn(),
}));
jest.mock("../../../services/common-service", () => ({
  dispatchError: jest.fn(),
}));

const mockedAxios = axios as jest.Mocked<typeof axios>;

describe("postBasicData", () => {
  beforeEach(() => {
    mockedAxios.post.mockReset();
    (store.getState as jest.Mock).mockReturnValue({
      stages: {
        stages: [
          {
            stageInfo: {
              application: {
                channel_reference: "mocked_channel_ref",
              },
            },
          },
        ],
      },
    });

    PreApprovalUtil.getFormConfigPayload.mockReturnValue({
      applicants: [],
      application: {},
    });

    PreApprovalUtil.getAckMetaData.mockReturnValue("mocked_ack_meta_data");
  });

  it("should call axios.post with correct arguments and resolve", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_BASIC_DATA_END_POINT = "/basic-data/";

    const mockedResponse = { data: "mocked_response" };
    mockedAxios.post.mockResolvedValueOnce(mockedResponse);

    const result = await postBasicData();

    const expectedUrl =
      "https://mock-base-url/application-endpoint/mocked_channel_ref/basic-data/";
    const expectedPayload = JSON.stringify({
      applicants: [],
      application: {},
    });
    const expectedHeaders = {
      "Content-Type": "application/json;charset=UTF-8",
      "Sc-Client-Context": "mocked_ack_meta_data",
    };

    expect(mockedAxios.post).toHaveBeenCalledWith(expectedUrl, expectedPayload, {
      headers: expectedHeaders,
    });
    expect(result).toEqual(mockedResponse);
  });

  it("should handle axios.post rejection and call dispatchError", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_BASIC_DATA_END_POINT = "/basic-data/";

    const mockedError = new Error("mocked_error");
    mockedAxios.post.mockRejectedValueOnce(mockedError);

    await expect(postBasicData()).rejects.toThrow("mocked_error");

    expect(dispatchError).toHaveBeenCalledWith(mockedError);
  });
});

import { postAditionalData } from "./yourFile";
import axios from "axios";
import { store } from "../../../utils/store/store";
import PreApprovalUtil from "./preApprovalUtils";
import { dispatchError } from "../../../services/common-service";
import { adpayload } from "./payload";

jest.mock("axios");
jest.mock("../../../utils/store/store", () => ({
  store: {
    getState: jest.fn(),
  },
}));
jest.mock("./preApprovalUtils", () => ({
  getAckMetaData: jest.fn(),
  getFormConfigPayload: jest.fn(),
}));
jest.mock("../../../services/common-service", () => ({
  dispatchError: jest.fn(),
}));
jest.mock("./payload", () => ({
  adpayload: jest.fn(() => ({
    applicants: [],
    fieldmetadata: {},
    products: [],
    stage: {},
    status: {},
    applicant_documents: [],
    client: {},
    dedupe: {},
    dedupeList: [],
    etc_data: {},
    lov_desc: {},
    oz_templates: [],
    preApprovedData: {},
    preapproved: {},
    service_response: {},
  })),
}));

const mockedAxios = axios as jest.Mocked<typeof axios>;

describe("postAditionalData", () => {
  beforeEach(() => {
    mockedAxios.post.mockReset();
    (store.getState as jest.Mock).mockReturnValue({
      stages: {
        stages: [
          {
            stageInfo: {
              application: {
                channel_reference: "mocked_channel_ref",
              },
            },
          },
        ],
      },
    });

    PreApprovalUtil.getAckMetaData.mockReturnValue("mocked_ack_meta_data");
    PreApprovalUtil.getFormConfigPayload.mockReturnValue({
      applicants: [{ id: "applicant-id" }],
      fieldmetadata: {},
      products: [],
      stage: {},
      status: {},
      applicant_documents: [],
      client: {},
      dedupe: {},
      dedupeList: [],
      etc_data: {},
      lov_desc: {},
      oz_templates: [],
      preApprovedData: {},
      preapproved: {},
      service_response: {},
    });
  });

  it("should call axios.post with correct arguments and resolve", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_ADDITIONAL_DATA_END_POINT = "/additional-data/";

    const mockedResponse = { data: "mocked_response" };
    mockedAxios.post.mockResolvedValueOnce(mockedResponse);

    const result = await postAditionalData();

    const expectedUrl =
      "https://mock-base-url/application-endpoint/mocked_channel_ref/additional-data/";
    const currentStageData = PreApprovalUtil.getFormConfigPayload();
    const expectedPayload = {
      ...adpayload(),
      applicants: currentStageData.applicants,
      fieldmetadata: currentStageData.fieldmetadata,
      products: currentStageData.products,
      stage: currentStageData.stage,
      status: currentStageData.status,
      applicant_documents: currentStageData.applicant_documents,
      client: currentStageData.client,
      dedupe: currentStageData.dedupe,
      dedupeList: currentStageData.dedupeList,
      etc_data: currentStageData.etc_data,
      lov_desc: currentStageData.lov_desc,
      oz_templates: currentStageData.oz_templates,
      preApprovedData: currentStageData.preApprovedData,
      preapproved: currentStageData.preapproved,
      service_response: currentStageData.service_response,
    };
    const expectedHeaders = {
      "Content-Type": "application/json;charset=UTF-8",
      "Sc-Client-Context": "mocked_ack_meta_data",
    };

    expect(mockedAxios.post).toHaveBeenCalledWith(expectedUrl, JSON.stringify(expectedPayload), {
      headers: expectedHeaders,
    });
    expect(result).toEqual(mockedResponse);
  });

  it("should handle axios.post rejection and call dispatchError", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_ADDITIONAL_DATA_END_POINT = "/additional-data/";

    const mockedError = new Error("mocked_error");
    mockedAxios.post.mockRejectedValueOnce(mockedError);

    await expect(postAditionalData()).rejects.toThrow("mocked_error");

    expect(dispatchError).toHaveBeenCalledWith(mockedError);
 
import { postAditionalData } from "./yourFile";
import axios from "axios";
import { store } from "../../../utils/store/store";
import PreApprovalUtil from "./preApprovalUtils";
import { dispatchError } from "../../../services/common-service";
import { adpayload } from "./payload";

jest.mock("axios");
jest.mock("../../../utils/store/store", () => ({
  store: {
    getState: jest.fn(),
  },
}));
jest.mock("./preApprovalUtils", () => ({
  getAckMetaData: jest.fn(),
  getADFormConfigPayload: jest.fn(),
}));
jest.mock("../../../services/common-service", () => ({
  dispatchError: jest.fn(),
}));
jest.mock("./payload", () => ({
  adpayload: jest.fn(() => ({
    applicants: [],
    fieldmetadata: {},
    products: [],
    stage: {},
    status: {},
    applicant_documents: [],
    client: {},
    dedupe: {},
    dedupeList: [],
    etc_data: {},
    lov_desc: {},
    oz_templates: [],
    preApprovedData: {},
    preapproved: {},
    service_response: {},
  })),
}));

const mockedAxios = axios as jest.Mocked<typeof axios>;

describe("postAditionalData", () => {
  beforeEach(() => {
    mockedAxios.post.mockReset();
    (store.getState as jest.Mock).mockReturnValue({
      stages: {
        stages: [
          {
            stageInfo: {
              application: {
                channel_reference: "mocked_channel_ref",
              },
            },
          },
        ],
      },
    });

    PreApprovalUtil.getAckMetaData.mockReturnValue("mocked_ack_meta_data");
  });

  it("should call axios.post with correct arguments and resolve when payload is an object", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_ADDITIONAL_DATA_END_POINT = "/additional-data/";

    // Mock payload as object
    PreApprovalUtil.getADFormConfigPayload.mockReturnValueOnce({
      applicants: [],
      application: {},
    });

    const mockedResponse = { data: "mocked_response" };
    mockedAxios.post.mockResolvedValueOnce(mockedResponse);

    const result = await postAditionalData();

    const expectedUrl =
      "https://mock-base-url/application-endpoint/mocked_channel_ref/additional-data/";
    const expectedPayload = JSON.stringify({
      ...adpayload(),
      applicants: [],
      application: {},
    });
    const expectedHeaders = {
      "Content-Type": "application/json;charset=UTF-8",
      "Sc-Client-Context": "mocked_ack_meta_data",
    };

    expect(mockedAxios.post).toHaveBeenCalledWith(expectedUrl, expectedPayload, {
      headers: expectedHeaders,
    });
    expect(result).toEqual(mockedResponse);
  });

  it("should call axios.post with correct arguments and resolve when payload is a JSON string", async () => {
    // Mock payload as JSON string
    PreApprovalUtil.getADFormConfigPayload.mockReturnValueOnce(
      JSON.stringify({
        applicants: [],
        application: {},
      })
    );

    const mockedResponse = { data: "mocked_response" };
    mockedAxios.post.mockResolvedValueOnce(mockedResponse);

    const result = await postAditionalData();

    const expectedUrl =
      "https://mock-base-url/application-endpoint/mocked_channel_ref/additional-data/";
    const expectedPayload = JSON.stringify({
      ...adpayload(),
      applicants: [],
      application: {},
    });
    const expectedHeaders = {
      "Content-Type": "application/json;charset=UTF-8",
      "Sc-Client-Context": "mocked_ack_meta_data",
    };

    expect(mockedAxios.post).toHaveBeenCalledWith(expectedUrl, expectedPayload, {
      headers: expectedHeaders,
    });
    expect(result).toEqual(mockedResponse);
  });

  it("should handle invalid JSON returned by getADFormConfigPayload", async () => {
    PreApprovalUtil.getADFormConfigPayload.mockReturnValueOnce("{invalidJSON}");

    await expect(postAditionalData()).rejects.toThrow(
      "Failed to parse getADFormConfigPayload: Invalid JSON string"
    );
  });

  it("should handle undefined or null return value from getADFormConfigPayload", async () => {
    PreApprovalUtil.getADFormConfigPayload.mockReturnValueOnce(undefined);

    await expect(postAditionalData()).rejects.toThrow(
      "getADFormConfigPayload returned undefined or null"
    );
  });

  it("should handle axios.post rejection and call dispatchError", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";
    process.env.REACT_APP_RTOB_ADDITIONAL_DATA_END_POINT = "/additional-data/";

    const mockedError = new Error("mocked_error");
    mockedAxios.post.mockRejectedValueOnce(mockedError);

    await expect(postAditionalData()).rejects.toThrow("mocked_error");

    expect(dispatchError).toHaveBeenCalledWith(mockedError);
  });
});

import { postDocSaveData } from "./yourFile";
import axios from "axios";
import { store } from "../../../utils/store/store";
import PreApprovalUtil from "./preApprovalUtils";
import { dispatchError } from "../../../services/common-service";

jest.mock("axios");
jest.mock("../../../utils/store/store", () => ({
  store: {
    getState: jest.fn(),
  },
}));
jest.mock("./preApprovalUtils", () => ({
  getFormConfigPayload: jest.fn(),
  getAckMetaData: jest.fn(),
}));
jest.mock("../../../services/common-service", () => ({
  dispatchError: jest.fn(),
}));

const mockedAxios = axios as jest.Mocked<typeof axios>;

describe("postDocSaveData", () => {
  beforeEach(() => {
    mockedAxios.post.mockReset();
    (store.getState as jest.Mock).mockReturnValue({
      stages: {
        stages: [
          {
            stageInfo: {
              application: {
                channel_reference: "mocked_channel_ref",
              },
            },
          },
        ],
      },
    });

    PreApprovalUtil.getFormConfigPayload.mockReturnValue({
      applicants: {},
      application: {},
    });

    PreApprovalUtil.getAckMetaData.mockReturnValue("mocked_ack_meta_data");
  });

  it("should call axios.post with correct arguments and resolve", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";

    const mockedResponse = { data: "mocked_response" };
    mockedAxios.post.mockResolvedValueOnce(mockedResponse);

    const documentData = [{ docId: "123", documentName: "doc_name" }];
    const transactionData = {
      transactionId: "trans123",
      result: { resultMessage: "success" },
    };

    const result = await postDocSaveData(documentData, transactionData);

    const expectedUrl =
      "https://mock-base-url/application-endpoint/mocked_channel_ref";
    const expectedPayload = JSON.stringify({
      applicants: {
        ekycdocId: "123",
        ekycdocumentName: "doc_name",
        zoloz_transaction_id: "trans123",
        zoloz_value: "success",
        work_type_a_1: "S001",
      },
      application: {},
    });
    const expectedHeaders = {
      "Content-Type": "application/json;charset=UTF-8",
      "Sc-Client-Context": "mocked_ack_meta_data",
    };

    expect(mockedAxios.post).toHaveBeenCalledWith(expectedUrl, expectedPayload, {
      headers: expectedHeaders,
    });
    expect(result).toEqual(mockedResponse);
  });

  it("should handle axios.post rejection and call dispatchError", async () => {
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = "https://mock-base-url";
    process.env.REACT_APP_RTOB_APPLICATION_END_POINT = "/application-endpoint/";

    const mockedError = new Error("mocked_error");
    mockedAxios.post.mockRejectedValueOnce(mockedError);

    const documentData = [{ docId: "123", documentName: "doc_name" }];
    const transactionData = {
      transactionId: "trans123",
      result: { resultMessage: "success" },
    };

    await expect(postDocSaveData(documentData, transactionData)).rejects.toThrow(
      "mocked_error"
    );

    expect(dispatchError).toHaveBeenCalledWith(mockedError);
  });
});



import {
  KeyWithAnyModel,
  StoreModel,
  DocumentModel,
} from "../../../utils/model/common-model";
import Footer from "../../../modules/dashboard/footer/footer";
import "./documet-upload.scss";
import { useEffect, useRef, useState } from "react";
import { useDispatch, useSelector } from "react-redux";
import { documentUploadAction } from "../../../utils/store/document-slice";
import {
  documentClientContext,
  fileuploadSuccess,
  fileValidation,
  filterDocuments,
  getDocumentMetaData,
  //getDocumentThumnail,
  setSuccessStatus,
  validateMandatoryDoc,
} from "./document-upload.utils";
import axios, { AxiosError } from "axios";
import {
  checkProductDetails,
  dispatchCtaLoader,
  dispatchLoader,
  documentSubmit,
  lovRequests,
} from "../../../services/common-service";
import PopupModel from "../popup-model/popup-model";
import {
  nextStage,
  stateUrl,
} from "../../../modules/dashboard/fields/stage.utils";
import { stagesAction } from "../../../utils/store/stages-slice";
import Model from "../model/model";
import { getUrl } from "../../../utils/common/change.utils";
import DocumentUploadRadioButton from "./document-upload-radio-button";
import DocumentFileUpload from "./document-file-upload";
import { loaderAction } from "../../../utils/store/loader-slice";
import { urlParamAction } from "../../../utils/store/urlparam-slice";
import trackEvents from "../../../services/track-events";
import { ValueUpdateAction } from "../../../utils/store/value-update-slice";
import { CONSTANTS } from "../../../utils/common/constants";
import { store } from "../../../utils/store/store";
import { StepCountAction } from "../../../utils/store/step-count-slice";
import { useNavigate } from "react-router-dom";

export const DocumentUpload = (props: any) => {
  const dispatch = useDispatch();
  const navigate = useNavigate();
  let [documentResponse, setDcoumentList] = useState<Array<KeyWithAnyModel>>(
    []
  );
  const documentStore = useSelector(
    (state: StoreModel) => state.documentUploadList
  );
  const valueSelector = useSelector((state: StoreModel) => state.valueUpdate);
  const applicationJourney = useSelector(
    (state: StoreModel) => state.stages.journeyType
  );
  const cancelFileUpload = useRef({});
  const [progress, setProgress] = useState<KeyWithAnyModel>({
    progressPercentage: 0,
  });

  const [documentArrList, setDocumentArrList] = useState<
    Array<KeyWithAnyModel>
  >([]);
  /*const [mandatoryDocumentsList, setMandatoryDocumentsList] = useState<
    Array<KeyWithAnyModel>
  >([]);*/
  const [mandatoryDocumentsList, setMandatoryDocumentsList] = useState<
    any
  >([]);
  const [uploadEnable, setUploadEnable] = useState(false);
  const [documentError, setDocumentError] = useState<KeyWithAnyModel>({
    errorType: null,
    enableError: null,
  });
  const [singleDocPreview, setSingleDocPreview] = useState<KeyWithAnyModel>({
    previewPopUp: false,
    imageUrl: null,
    documentType: null,
  });
  const documentStructureSelector = useSelector(
    (state: StoreModel) => state.documentUploadList
  );

  const [documentState, setDocumentState] = useState<any>(null);
  const [tmpDocumentState, setTmpDocumentState] = useState<any>(null);

  const stageSelector = useSelector((state: StoreModel) => state.stages.stages);

  let documentStoreCopy = JSON.parse(
    JSON.stringify(Object.assign([], documentStore.responseDocuments))
  );
  let documentList = JSON.parse(
    JSON.stringify(
      Object.assign([], stageSelector[0].stageInfo.applicant_documents)
    )
  );

  const [refernceDetails, setRefernceDetails] = useState({
    channelReference: "",
    applicationReferenceNo: "",
  });

  useEffect(() => {
    //dispatch(fieldErrorAction.getMandatoryFields(null));
    dispatch(dispatchLoader(false));
    setRefernceDetails({
      channelReference: getUrl.getChannelRefNo().channelRefNo!,
      applicationReferenceNo: getUrl.getChannelRefNo().applicationRefNo!,
    });
    dispatch(
      loaderAction.getState({
        isFetching: false,
      })
    );
    if(getUrl.getParameterByName("auth") === "upload" || store.getState().stages.isDocumentUpload){
      setUploadEnable(true)
     }
    setDocumentState(JSON.parse(JSON.stringify(documentStructureSelector)));
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  useEffect(() => {
    if (documentState && documentState.responseDocuments) {
      documentState.responseDocuments = documentResponse;
      dispatch(
        documentUploadAction.getDocumentList(
          JSON.parse(JSON.stringify(documentState))
        )
      );
    }

    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [tmpDocumentState]);

  const documentHeaders = (header: string) => {
    if (header) {
      return "Upload your " + header.toLocaleLowerCase();
    }
  };

  useEffect(() => {
    setDocumentArrList(
      documentStore.responseDocuments.length > 0
        ? documentStoreCopy
        : filterDocuments(documentList)
    );
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  useEffect(() => {
    if(documentList.finalDocument && documentList.finalDocument.finalDocumentList && documentList.finalDocument.finalDocumentList.length > 0){
      setDocumentState(documentList.finalDocument);
      dispatch(documentUploadAction.isDocumentUpdate(true));
      delete documentList.finalDocument;
    }

    setDcoumentList(documentArrList);
    if(getUrl.getParameterByName("auth") === "upload")
    {setMandatoryDocumentsList(getMandatoryFields(documentArrList));}
    else if (documentArrList && documentArrList.length > 0 && documentArrList[0].isSignatureDoc) {
      setMandatoryDocumentsList({ R0006: 1 })
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [documentStore, documentArrList]);

  const getMandatoryFields = (
    documentResponseData: DocumentModel | any
  ): any => {
    let mandatoryFields: KeyWithAnyModel = [];
    if (documentResponseData && documentResponseData[0]) {
      documentResponseData[0].document_list.forEach((doc: KeyWithAnyModel) => {
        if (doc.min_options_req > 0) {
          mandatoryFields[doc.document_category_code] = doc.min_options_req;
        }
      });
      return mandatoryFields;
    }
  };

  /** assigning selected document */
  const setCheckedFlag = (documentCategory: string, documentCode: string) => {
    documentResponse[0].document_list.forEach((docOption: KeyWithAnyModel) => {
      if (docOption.document_category_code === documentCategory) {
        docOption.docCheck = "Y";
        docOption.document_options.forEach((docList: KeyWithAnyModel) => {
          docList.document_types.forEach((documentSegment: KeyWithAnyModel) => {
            if (documentSegment.document_type_code === documentCode) {
              documentSegment.uploaded_documents = {
                tempDocStore: {
                  isSelected: "Y",
                },
              };
              documentSegment.selectDocument = documentSegment.document_type;
            } else {
              documentSegment.uploaded_documents = null;
              documentSegment.selectDocument = null;
            }
          });
        });
      }
    });
    setDcoumentList([...documentResponse]);
  };

  /** setting flag for uploading document*/
  const uploadDocument = (
    documentTypes: KeyWithAnyModel,
    event: React.FormEvent<EventTarget>
  ): void => {
    if(!store.getState().stages.isDocumentUpload && getUrl.getParameterByName("auth") !== "upload"){
    trackEvents.triggerAdobeEvent("ctaClick", "Upload Document");
    }
    if (documentTypes.docCheck === "Y") {
      documentResponse[0].document_list.forEach(
        (docOption: KeyWithAnyModel) => {
          if (
            docOption.document_category_code ===
            documentTypes.document_category_code
          ) {
            docOption.isSlectedForUpload = "Y";
          }
        }
      );
      setDcoumentList([...documentResponse]);
    } else {
      setDocumentError({
        errorType: "selectDocument",
        enableError: true,
      });
    }
    event.preventDefault();
  };

  /** File uplod -- main method */
  const changeHandler = async (
    uploadingDocument: KeyWithAnyModel,
    documentTypes: KeyWithAnyModel,
    event: any,
    indexOfUpload: number
  ) => {
    const documentArr = fileValidation(event.target.files, uploadingDocument);
    if (documentArr.enableError) {
      setDocumentError(documentArr);
    } else {
      await fileUpload(
        uploadingDocument,
        event.target.files[0],
        documentTypes,
        indexOfUpload
      )
        .then((response: any) => {
          dispatch(documentUploadAction.isDocumentUpdate(true));
          console.log("change handler", response);
        })
        .catch((error: AxiosError) => {
          console.log("catch error--", error);
        });
    }
  };

  /** Single file upload -- child method */
  const fileUpload = async (
    uploadingDocument: KeyWithAnyModel,
    file: any,
    documentTypes: KeyWithAnyModel,
    indexOfUpload: number
  ) => {
    let selectedDocument: KeyWithAnyModel = [];
    const url = `applications/${refernceDetails.channelReference}${process.env.REACT_APP_DOCUMENT_UPLOAD}`;
    selectedDocument = documentTypes.document_options.filter(
      (doc: KeyWithAnyModel) =>
        !!doc.document_types[0].uploaded_documents &&
        doc.document_types[0].uploaded_documents.length >= 0
    );
    const getMetaData = getDocumentMetaData(selectedDocument, documentTypes);
    let scClientContextHeaders = documentClientContext(
      refernceDetails.channelReference!
    );
    let header : any = {}
    header["SC-CLIENT-CONTEXT"] = JSON.stringify(scClientContextHeaders)
    if (process.env.REACT_APP_ENVIRONMENT === "uat") {
      header["Env"] = process.env.REACT_APP_ENVIRONMENT;
    };
    selectedDocument[0].document_types[0].documentStatus = "UPLOADING";
    let data = new FormData();
    data.append("file", file);
    data.append("documentJson", JSON.stringify(getMetaData));

    const options = {
      onUploadProgress: (progressEvent: any) => {
        setProgressPercentage(documentTypes, progressEvent, uploadingDocument);
      },
      cancelToken: new axios.CancelToken(
        (cancel) => (cancelFileUpload.current = cancel)
      ),
    };
    uploadingDocument.document_name = file.name;
    uploadingDocument.documentStatus = "UPLOADING";
    const docaxios = axios.create({
      headers: header,
      baseURL: process.env.REACT_APP_RTOB_BASE_URL,
    });

    await docaxios
      .post(url, data, options)
      .then(async (response) => {
        if (response) {
          /** setting flag for uploaded document */
          await dispatch(
            setSuccessStatus(
              documentResponse,
              documentTypes,
              selectedDocument,
              response.data,
              indexOfUpload
            )
          ).then(async () => {
            await dispatch(
              fileuploadSuccess(
                selectedDocument[0].document_types,
                response.data
              )
            ).then((successFileResponse: any) => {
              /** adding the response to an array, to send in acknwoledge document */
              setDocumentState((prev: any) => {
                prev.finalDocumentList.push(successFileResponse);
                if (
                  prev.optionList.docOption.indexOf(
                    selectedDocument[0].document_types[0].document_type_code
                  ) === -1
                ) {
                  prev.optionList.docOption.push(
                    selectedDocument[0].document_types[0].document_type_code
                  );
                  prev.optionList.optionsSelected.options.push({
                    documentCategoryCode: documentTypes.document_category_code,
                    documentOptionSequence: 1,
                    documentTypeCode:
                      selectedDocument[0].document_types[0].document_type_code,
                  });
                }
                return prev;
              });
            });
          });
          setTmpDocumentState((tmpData: any) => ({
            ...tmpData,
            documentState,
          }));
          setDcoumentList([...documentResponse]);
          return Promise.resolve();
        }
      })
      .catch((err: AxiosError) => {
        uploadingDocument.documentStatus = "REJECTED";
        setDcoumentList([...documentResponse]);
      });
  };

  /** setting progressBar */
  const setProgressPercentage = (
    documentTypes: any,
    progressEvent: any,
    uploadingDocument: any
  ) => {
    const { loaded, total } = progressEvent;
    const percent = Math.floor((loaded * 100) / total);
    console.log(
      `${loaded}kb of ${total}kb | ${percent}%`
    ); /** just to see whats happening in the console */
    setProgress((prevUser: any) => ({
      ...prevUser,
      [documentTypes.document_category_code]: { progressPercentage: percent },
    }));
    uploadingDocument.progress = percent;
  };

  const cancelUpload = () => {
    if (cancelFileUpload.current) {
      cancelFileUpload.current = "User Cancelled!!!";
    }
  };
  /** fileDelete */
  const deleteFile = (
    uploadedDocuments: KeyWithAnyModel,
    documentTypes: KeyWithAnyModel,
    indexofUpload: number,
    status: string
  ) => {
    if (
      uploadedDocuments.length > 0 &&
      status !== "REJECTED" &&
      status !== "FAILED"
    ) {
      dispatch(documentUploadAction.isDocumentUpdate(true));
      let isDocAvailable = false;
      documentState.finalDocumentList.forEach(
        (uploadList: KeyWithAnyModel, index: number) => {
          if (uploadList.docId === uploadedDocuments[indexofUpload].docId) {
            isDocAvailable = true;
            documentState.finalDocumentList[index].documentStatus = "Rejected"
          }
        }
      );
      if(!isDocAvailable){
        uploadedDocuments[indexofUpload].documentStatus = "Rejected";
        documentState.finalDocumentList.push(uploadedDocuments[indexofUpload])
      }
    }

    if (uploadedDocuments.length > 0) {
      uploadedDocuments.splice(indexofUpload, 1);
    }

    if (uploadedDocuments.length === 0) {
      documentResponse[0].document_list.forEach(
        (docOption: KeyWithAnyModel) => {
          if (
            docOption.document_category_code ===
            documentTypes.document_category_code
          ) {
            docOption.docCheck = "N";
            docOption.isSlectedForUpload = "N";
          }
        }
      );
    }
    setTmpDocumentState((tmpData: any) => ({
      ...tmpData,
      documentState,
    }));
    setDcoumentList([...documentResponse]);
  };

  /** Added for clarification - dont remove */

  const addDocument = (
    documentType: KeyWithAnyModel,
    docCategory: KeyWithAnyModel,
    event: any,
    index: number
  ) => {
    documentResponse[0].document_list.forEach((docOption: KeyWithAnyModel) => {
      if (docOption.document_category_code === docCategory) {
        docOption.document_options.forEach((docList: KeyWithAnyModel) => {
          docList.document_types.forEach((documentSegment: KeyWithAnyModel) => {
            if (
              documentSegment.document_type_code ===
              documentType.document_type_code
            ) {
              if (
                documentSegment.uploaded_documents[index].documentStatus &&
                documentSegment.uploaded_documents[index].documentStatus !==
                  null
              ) {
                documentSegment.uploaded_documents.push({
                  document_type_code: documentSegment.document_type_code,
                  documentStatus: null,
                  selectDocument: documentType.document_type,
                });
              }
            }
          });
        });
      }
    });
    setDcoumentList([...documentResponse]);
    event.preventDefault();
  };

  const submitDocument = (event: React.FormEvent<EventTarget>): void => {
    dispatch(
      validateMandatoryDoc(documentResponse, mandatoryDocumentsList)
    ).then((response: any) => {
      if (Object.keys(response).length > 0) {
        setDocumentError({
          errorType: "missingMandatoryDocument",
          enableError: true,
        });
      } else {
        dispatch(stagesAction.setLastStageId("doc"));
        documentAcknowledge(event);
      }
    });
    event.preventDefault();
  };

  const documentAcknowledge = (event: React.FormEvent<EventTarget>): void => {
    dispatch(dispatchCtaLoader(true));
    if ((getUrl.getDocumentStatus())||uploadEnable) {
      dispatch(urlParamAction.getUrlEndPoit("acknowledge"));
      documentSubmit(
        refernceDetails.applicationReferenceNo!,
        refernceDetails.channelReference!,
        documentState
      )
      .then(async(res: any) => {
          dispatch(documentUploadAction.isDocumentUpdate(false));
          documentState.finalDocumentList = [];
          dispatch(urlParamAction.getUrlEndPoit("success"));
          if(!store.getState().stages.isDocumentUpload && getUrl.getParameterByName("auth") !== "upload"){
          trackEvents.triggerAdobeEvent(
            "ctaClick",
            "Continue",
            documentResponse
          );
          }
          dispatch(dispatchCtaLoader(false));
          documentState.responseDocuments = documentResponse;
          dispatch(documentUploadAction.getDocumentList(documentState));
          if (uploadEnable) {
            
            navigate("/sg/thankyou");
          }
          
          else{
          const state = nextStage("doc", applicationJourney);
          stateUrl(state);
          dispatch(stagesAction.resetCurrentStage(state));
          dispatch(stagesAction.updateStageId(state));
          dispatch(StepCountAction.modifyStepCount(state));
          if(!store.getState().stages.isDocument){
            dispatch(lovRequests(stageSelector[0].stageInfo, state));
          }

          if (getUrl.getJourneyType()) {
            const productsSelector = stageSelector[0].stageInfo.products;
            let JourneyType;
            if (getUrl.getJourneyType() === "ETC") {
              JourneyType = checkProductDetails(productsSelector)
                ? "ETC_CASA"
                : "ETC_CC";
            } else {
              JourneyType = checkProductDetails(productsSelector)
                ? "NON_ETC_CASA"
                : "NON_ETC_CC";
            }
            const nextStage = CONSTANTS[JourneyType];
            const nextStageId = valueSelector.backNavigation.nextStageId;
            let stageUpdate =
              nextStageId && nextStage[state].step > nextStage[nextStageId].step
                ? true
                : false;
            if (
              nextStageId &&
              stageUpdate === false &&
              nextStage[nextStageId].path === "document"
            ) {
              stageUpdate = true;
            }
            dispatch(stagesAction.setIsDocument(true));
            if (!nextStageId || stageUpdate) {
              dispatch(ValueUpdateAction.getNextStageId(state));
            }
          }}
        })
        .catch(() => {
          dispatch(dispatchCtaLoader(false));
        });
    } else {
      dispatch(urlParamAction.getUrlEndPoit("success"));
      if(!store.getState().stages.isDocumentUpload && getUrl.getParameterByName("auth") !== "upload"){
      trackEvents.triggerAdobeEvent("ctaClick", "Continue", documentResponse);
      }
      dispatch(dispatchCtaLoader(false));
      const state = nextStage("doc", applicationJourney);
      stateUrl(state);
      dispatch(stagesAction.resetCurrentStage(state));
      dispatch(stagesAction.updateStageId(state));
      // if(stageSelector[0].stageInfo.applicants['casa_fatca_declaration_a_1']) {
      // dispatch(isFormUpdate(null));
      // }
      if(!store.getState().stages.isDocument){
        dispatch(lovRequests(stageSelector[0].stageInfo, state));
      }
      dispatch(stagesAction.setIsDocument(true));
    }
    event.preventDefault();
  };
  const documentHandleBack = () => {
    if(!store.getState().stages.isDocumentUpload && getUrl.getParameterByName("auth") !== "upload"){
    trackEvents.triggerAdobeEvent("ctaClick", "Back");
    }
    setDocumentError({
      errorType: "",
      enableError: false,
    });
  };

  // const getThumbnail = (uploadedDocList: KeyWithAnyModel, type: string) => {
  //   if (uploadedDocList.docId || (uploadedDocList.document_id && uploadedDocList.document_id.includes("."))) {
  //     dispatch(
  //       getDocumentThumnail(uploadedDocList, type, refernceDetails)
  //     ).then((res: any) => {
  //       uploadedDocList.imageUrl = res;
  //       setDcoumentList([...documentResponse]);
  //       return uploadedDocList;
  //     });
  //   } else {
  //     return "";
  //   }
  // };

  // const openDocPreview = (uploadingDocument: KeyWithAnyModel) => {
  //   const documentName = uploadingDocument.document_id ? uploadingDocument.document_id : uploadingDocument.document_name
  //   const documentType =documentName.split(".").pop();
  //   setSingleDocPreview({
  //     previewPopUp: true,
  //     imageUrl: uploadingDocument.imageUrl,
  //     documentType: documentType,
  //   });
  // };

  const closePreview = () => {
    setSingleDocPreview({
      previewPopUp: false,
      imageUrl: "",
      documentType: null,
    });
  };

  const documentBackHandler = () => {
    if (store.getState().stages.isDocument) {
      // if (valueSelector.backNavigation.nextStageId === "doc") {
      props.backHandler(false);
    } else {
      props.backHandler();
    }
  };

  // const documentExtension = (uploadingDocument:KeyWithAnyModel) =>{
  //   let docName = uploadingDocument.document_id ? uploadingDocument.document_id : uploadingDocument.document_name;
  //   return docName.split(".").pop()
  // }
  return (
    <>
      <form className="form" onSubmit={submitDocument}>
        {documentResponse &&
          documentResponse.map((docList: KeyWithAnyModel, index_i: number) => {
            return (
              <div key={index_i}>
                <div className="document-upload">
                  {docList.document_list.map(
                    (documentTypes: KeyWithAnyModel, index_j: number) => {
                      return (
                        <div
                          className="document-upload__doc-type"
                          key={index_j}
                        >
                          <p className="document-upload__doc-type__header">
                            {documentHeaders(documentTypes.document_category)}
                          </p>
                          <div className="document-upload__doc-list">
                            {documentTypes.document_options.map(
                              (
                                docTypeList: KeyWithAnyModel,
                                docTypeList_key: number
                              ) => {
                                return (
                                  /** Document with radio button List section */
                                  <div key={`dockList${docTypeList_key}`}>
                                    {documentTypes.isSlectedForUpload !==
                                    "Y" ? (
                                      <DocumentUploadRadioButton
                                        documentList={docTypeList}
                                        documentTypes={documentTypes}
                                        setCheckedFlag={setCheckedFlag}
                                      />
                                    ) : (
                                      <div className="document-upload__file-upload">
                                        {docTypeList.document_types.map(
                                          (
                                            docType: KeyWithAnyModel,
                                            docType_key: number
                                          ) => {
                                            return (
                                              <div
                                                key={`docType${docType_key}`}
                                              >
                                                {docType.uploaded_documents &&
                                                  docType.uploaded_documents
                                                    .length >= 0 &&
                                                  docType.uploaded_documents.map(
                                                    (
                                                      uploadingDocument: KeyWithAnyModel,
                                                      upload_Index: number
                                                    ) => {
                                                      return (
                                                        <div
                                                          key={`uploadDoc${upload_Index}`}
                                                        >
                                                          {!uploadingDocument.documentStatus && (
                                                            <div
                                                              key={`uploadList${upload_Index}`}
                                                            >
                                                              {/* Document upload */}
                                                              <DocumentFileUpload
                                                                changeHandler={
                                                                  changeHandler
                                                                }
                                                                documentHeaders={
                                                                  documentHeaders
                                                                }
                                                                index={
                                                                  upload_Index
                                                                }
                                                                documentTypes={
                                                                  documentTypes
                                                                }
                                                                docType={
                                                                  docType
                                                                }
                                                                uploadingDocument={
                                                                  uploadingDocument
                                                                }
                                                              />
                                                              {/* Document upload */}
                                                            </div>
                                                          )}

                                                          {/* Document Upload progress */}

                                                          {uploadingDocument.documentStatus &&
                                                            uploadingDocument.documentStatus !==
                                                              "Accepted" && uploadingDocument.documentStatus !==
                                                              "Rejected" && (
                                                              <div
                                                                key={`uploadStatus${upload_Index}`}
                                                                className={`document-upload__file-upload__upload-section ${uploadingDocument.documentStatus} `}
                                                              >
                                                                <div
                                                                  className="documentavatar"
                                                                  id="documentavatar"
                                                                >
                                                                  {!(
                                                                    uploadingDocument.docId ||
                                                                    uploadingDocument.document_id
                                                                  ) &&
                                                                    !uploadingDocument.imageUrl && (
                                                                      <span></span>
                                                                    )}

                                                                  {(uploadingDocument.docId ||
                                                                    uploadingDocument.document_id) &&
                                                                    !uploadingDocument.imageUrl && (
                                                                      <>
                                                                        <img
                                                                          alt="loading..."
                                                                          className="document-upload__file-upload__hide-upload"
                                                                          // src={getThumbnail(
                                                                          //   uploadingDocument,
                                                                          //   "image"
                                                                          // )}
                                                                          id={
                                                                            "preview_" +
                                                                            documentTypes.document_category +
                                                                            "_" +
                                                                            upload_Index
                                                                          }
                                                                        />
                                                                        <label
                                                                          className="upload-inprogress"
                                                                          htmlFor={
                                                                            "preview_" +
                                                                            documentTypes.document_category +
                                                                            "_" +
                                                                            upload_Index
                                                                          }
                                                                        ></label>
                                                                      </>
                                                                    )}
                                                                </div>

                                                                <div className="document-details">
                                                                  <span className="document-title">
                                                                    {documentHeaders(
                                                                      docType.document_type
                                                                    )}
                                                                  </span>
                                                                  <span
                                                                    style={{
                                                                      width: `${
                                                                        progress[
                                                                          documentTypes
                                                                            .document_category_code
                                                                        ]
                                                                          ? progress[
                                                                              documentTypes
                                                                                .document_category_code
                                                                            ]
                                                                              .progressPercentage
                                                                          : uploadingDocument.progress
                                                                          ? uploadingDocument.progress
                                                                          : 0
                                                                      }%`,
                                                                    }}
                                                                    className={`document-description--progress-bar__ ${
                                                                      documentTypes.document_category_code
                                                                    } ${
                                                                      uploadingDocument.documentStatus ===
                                                                      "REJECTED"
                                                                        ? "document-rejected"
                                                                        : ""
                                                                    } `}
                                                                  ></span>

                                                                  {(uploadingDocument.documentStatus ===
                                                                    "UPLOAD" ||
                                                                    uploadingDocument.documentStatus ===
                                                                      "UPLOADING") && (
                                                                    <span
                                                                      className={`document-description--progress-status`}
                                                                      onClick={
                                                                        cancelUpload
                                                                      }
                                                                    >
                                                                      Uploading
                                                                      in
                                                                      progress...{" "}
                                                                      {
                                                                        uploadingDocument.progress
                                                                      }
                                                                      %
                                                                    </span>
                                                                  )}
                                                                  {uploadingDocument.documentStatus ===
                                                                    "REJECTED" && (
                                                                    <span
                                                                      className={`document-description--progress-status`}
                                                                    >
                                                                      Upload
                                                                      failed...
                                                                    </span>
                                                                  )}
                                                                </div>
                                                                <label className="upload-icon">
                                                                  {uploadingDocument.documentStatus ===
                                                                    "REJECTED" && (
                                                                    <span
                                                                      className="upload-icon--failure"
                                                                      onClick={() => {
                                                                        deleteFile(
                                                                          docType.uploaded_documents,
                                                                          documentTypes,
                                                                          upload_Index,
                                                                          "FAILED"
                                                                        );
                                                                      }}
                                                                    ></span>
                                                                  )}
                                                                  {uploadingDocument.documentStatus ===
                                                                    "UPLOADING" && (
                                                                    <span className="upload-icon--progress"></span>
                                                                  )}
                                                                </label>
                                                              </div>
                                                            )}

                                                          {/* Document Upload progress */}

                                                          {/* Document upload success */}

                                                          {uploadingDocument.documentStatus ===
                                                            "Accepted" && (
                                                            <>
                                                              <div
                                                                className={`document-upload__file-upload__upload-section ${uploadingDocument.documentStatus} `}
                                                              >
                                                                <div
                                                                  className="documentavatar"
                                                                  id="documentavatar"
                                                                >
                                                                  {!(
                                                                    uploadingDocument.docId ||
                                                                    uploadingDocument.document_id
                                                                  ) &&
                                                                    uploadingDocument &&
                                                                    !uploadingDocument.imageUrl && (
                                                                      <>
                                                                        <img
                                                                          alt="loading..."
                                                                          className="document-upload__file-upload__hide-upload"
                                                                          // src={getThumbnail(
                                                                          //   uploadingDocument,
                                                                          //   "image"
                                                                          // )}
                                                                          id={
                                                                            "preview_" +
                                                                            documentTypes.document_category +
                                                                            "_" +
                                                                            upload_Index
                                                                          }
                                                                        />
                                                                        <label
                                                                          className="upload-inprogress"
                                                                          htmlFor={
                                                                            "preview_" +
                                                                            documentTypes.document_category +
                                                                            "_" +
                                                                            upload_Index
                                                                          }
                                                                        ></label>
                                                                      </>
                                                                    )}
                                                                  {(uploadingDocument.docId ||
                                                                    uploadingDocument.document_id) && (
                                                                    <>
                                                                      <div
                                                                        className="documentavatar--pfdPreview"
                                                                        // onClick={() =>
                                                                        //   openDocPreview(
                                                                        //     uploadingDocument
                                                                        //   )
                                                                        // }
                                                                      >
                                                                        {/* {documentExtension(uploadingDocument) === "pdf" ? (
                                                                            <Pdf
                                                                              fileName={
                                                                                uploadingDocument.imageUrl
                                                                              }
                                                                              numPages={
                                                                                1
                                                                              }
                                                                              continueBtn={
                                                                                false
                                                                              }
                                                                            />
                                                                          ) : (
                                                                            // <img
                                                                            //   alt="loading..."
                                                                            //   src={
                                                                            //     uploadingDocument.imageUrl
                                                                            //   }
                                                                            //   onClick={() =>
                                                                            //     openDocPreview(
                                                                            //       uploadingDocument
                                                                            //     )
                                                                            //   }
                                                                            // />
                                                                          )} */}
                                                                        <span className="document-completion"></span>
                                                                      </div>
                                                                    </>
                                                                  )}
                                                                </div>
                                                                <div className="document-details">
                                                                  <span className="document-title">
                                                                    {documentHeaders(
                                                                      docType.document_type
                                                                    )}
                                                                  </span>
                                                                  <span
                                                                    className={`document-description--progress-bar__ ${documentTypes.document_category_code}`}
                                                                  ></span>
                                                                  <span className="document-description--progress-status">
                                                                    File is
                                                                    successfully
                                                                    uploaded.
                                                                  </span>
                                                                </div>
                                                                <label className="upload-icon">
                                                                  <span
                                                                    className="upload-icon--success"
                                                                    onClick={() => {
                                                                      deleteFile(
                                                                        docType.uploaded_documents,
                                                                        documentTypes,
                                                                        upload_Index,
                                                                        "SUCCESS"
                                                                      );
                                                                    }}
                                                                  ></span>
                                                                </label>
                                                              </div>
                                                            </>
                                                          )}

                                                          {/* Document upload success */}

                                                          {/* Document add button */}
                                                          {(uploadingDocument.documentStatus ===
                                                            "Accepted" ||
                                                            uploadingDocument.documentStatus ===
                                                              "UPLOADED") &&
                                                            docType
                                                              .uploaded_documents
                                                              .length -
                                                              1 ===
                                                              upload_Index && (
                                                              <div className="document-upload__doc-type__upload">
                                                                <button
                                                                  className="document-upload__doc-type__upload-btn"
                                                                  onClick={(
                                                                    event
                                                                  ) =>
                                                                    addDocument(
                                                                      docType,
                                                                      documentTypes.document_category_code,
                                                                      event,
                                                                      upload_Index
                                                                    )
                                                                  }
                                                                >
                                                                  Upload
                                                                </button>
                                                              </div>
                                                            )}
                                                          {/* Document add button */}
                                                        </div>
                                                      );
                                                    }
                                                  )}
                                              </div>
                                            );
                                          }
                                        )}
                                      </div>
                                    )}
                                  </div>
                                  /** Document with radio button List section */
                                );
                              }
                            )}
                          </div>

                          {/* Document upload section */}
                          {documentTypes.isSlectedForUpload !== "Y" && (
                            <div className="document-upload__doc-type__upload">
                              <button
                                className="document-upload__doc-type__upload-btn"
                                onClick={(e) =>
                                  uploadDocument(documentTypes, e)
                                }
                              >
                                Upload
                              </button>
                            </div>
                          )}
                        </div>
                      );
                    }
                  )}
                </div>
              </div>
            );
          })}

        <div className="document-upload__footer-notes">
          Please ensure that the attached file(s) is of the following
          specification:
          <ul>
            {documentResponse &&
              documentResponse[0] &&
              documentResponse[0].isSignatureDoc && (
                <li>JPG and PNG formats only for Signature Specimen.</li>
              )}
            <li>JPG, PNG, TIFF, and PDF formats</li>
            <li>less than 5 MB.</li>
            <li>Taken without flash.</li>
            <li>File is not encrypted with passwords.</li>
            <li>Your full name is included in all files.</li>
            <li>File is clear and visible to read.</li>
          </ul>
          {documentResponse &&
            documentResponse[0] &&
            documentResponse[0].isSignatureDoc && (
              <p className="signature-doc-notes">
                <span>*</span>I confirm that the electronic image of my
                signature provided is correct and it is also the specimen
                signature that will be used to verify my instruction(s) for this
                account.
              </p>
            )}
        </div>
        <div className="app__footer">
          <Footer
            otherMyinfo={false}
            backHandler={documentBackHandler}
            documentFlag={true}
            uploadJourney={uploadEnable}
          />
        </div>
      </form>

      {/* Error pop up */}
      {documentError.enableError && (
        <PopupModel displayPopup={true}>
          <Model
            name={documentError.errorType}
            handlebuttonClick={documentHandleBack}
            callBackMethod={true}
          />
        </PopupModel>
      )}
      {/* Error pop up */}

      {/* Preview pop up */}
      {singleDocPreview.previewPopUp && (
        <PopupModel displayPopup={true}>
          <span
            className="document_preview-pop-up__close-btn"
            onClick={() => closePreview()}
          >
            X
          </span>
          <div className="document_preview-pop-up popup">
            <div
              id={singleDocPreview.documentType}
              className="popup-container1"
            >
                <img alt="loading..." src={singleDocPreview.imageUrl} />
            </div>
          </div>
        </PopupModel>
      )}
      {/* Preview pop up */}
    </>
  );
};

export default DocumentUpload;

