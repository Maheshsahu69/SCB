import { fieldGroupingFunc } from './Fields.utils'; // Import the function to mock

jest.mock('./Fields.utils', () => ({
  fieldGroupingFunc: jest.fn(),
}));

describe('groupObj function', () => {
  const mockResponse = {
    fields: [
      { field_set_name: 'group1', field_name: 'field1', value: 'val1' },
      { field_set_name: 'group1', field_name: 'field2', value: 'val2' },
      { field_set_name: 'group2', field_name: 'field3', value: 'val3' },
    ],
  };

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should group fields correctly', () => {
    const groupObj = (response: any) => {
      return response.fields.reduce(
        (prev: any[], { field_set_name, ...items }) => {
          let id = prev.findIndex(
            (item: any) => item.field_set_name === field_set_name
          );
          fieldGroupingFunc(id, prev, field_set_name, items);
          return prev;
        },
        []
      );
    };

    // Mock implementation of fieldGroupingFunc
    fieldGroupingFunc.mockImplementation((id, prev, field_set_name, items) => {
      if (id >= 0) {
        prev[id].fields.push(items);
      } else {
        prev.push({ field_set_name, fields: [items] });
      }
    });

    const result = groupObj(mockResponse);

    expect(result).toEqual([
      {
        field_set_name: 'group1',
        fields: [
          { field_name: 'field1', value: 'val1' },
          { field_name: 'field2', value: 'val2' },
        ],
      },
      {
        field_set_name: 'group2',
        fields: [{ field_name: 'field3', value: 'val3' }],
      },
    ]);

    // Verify fieldGroupingFunc calls
    expect(fieldGroupingFunc).toHaveBeenCalledTimes(3);
    expect(fieldGroupingFunc).toHaveBeenCalledWith(
      -1,
      expect.any(Array),
      'group1',
      { field_name: 'field1', value: 'val1' }
    );
    expect(fieldGroupingFunc).toHaveBeenCalledWith(
      0,
      expect.any(Array),
      'group1',
      { field_name: 'field2', value: 'val2' }
    );
    expect(fieldGroupingFunc).toHaveBeenCalledWith(
      -1,
      expect.any(Array),
      'group2',
      { field_name: 'field3', value: 'val3' }
    );
  });

  it('should handle empty fields array', () => {
    const groupObj = (response: any) => {
      return response.fields.reduce(
        (prev: any[], { field_set_name, ...items }) => {
          let id = prev.findIndex(
            (item: any) => item.field_set_name === field_set_name
          );
          fieldGroupingFunc(id, prev, field_set_name, items);
          return prev;
        },
        []
      );
    };

    const result = groupObj({ fields: [] });

    expect(result).toEqual([]);
    expect(fieldGroupingFunc).not.toHaveBeenCalled();
  });

  it('should handle missing field_set_name gracefully', () => {
    const invalidResponse = {
      fields: [{ field_name: 'field1', value: 'val1' }],
    };

    const groupObj = (response: any) => {
      return response.fields.reduce(
        (prev: any[], { field_set_name, ...items }) => {
          let id = prev.findIndex(
            (item: any) => item.field_set_name === field_set_name
          );
          fieldGroupingFunc(id, prev, field_set_name, items);
          return prev;
        },
        []
      );
    };

    expect(() => groupObj(invalidResponse)).toThrow(); // Optional: Check behavior on missing data
  });
});
