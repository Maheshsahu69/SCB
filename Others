import React, { useEffect, useState,useRef } from "react";
import { useDispatch,useSelector } from "react-redux";
import { BrowserRouter } from "react-router-dom";
import "./utils/styles/App.scss";
import Main from "./router/main";
import Model from "./shared/components/model/model";
import Spinner from "./shared/components/spinner/spinner";
import { KeyWithAnyModel, StoreModel } from "./utils/model/common-model";
import DynamicModel from "./shared/components/model/dynamic-model";
import ActivityDetector from "react-activity-detector";
import IdleTimeOutModel from "./shared/components/model/idle-time-out";
import trackEvents from "./services/track-events";
import { submitRequest } from "./modules/dashboard/fields/fields.utils";
import { store } from "./utils/store/store";

export const App = () => {
  const loaderSelector = useSelector((state: StoreModel) => state.loader);
  const errorSelector = useSelector((state: StoreModel) => state.error);
  const [loaderState, setLoaderState] = useState(null);
  const [error, setError] = useState([]);
  const [exceptionList, setExceptionList] = useState<KeyWithAnyModel>([]);
  const [isIdle, setIsIdle] = useState(false);
  const [openIdlePopUp, setOpenIdlePopUp] = useState(false);
  const idleTimeoutRef=useRef<NodeJS.Timeout| null>(null);
  const dispatch = useDispatch();

  /**
   * Added to disabled right click options
   */
  useEffect(() => {
    window.addEventListener('contextmenu', function (event) {
      event.preventDefault();
    });
    return () => {
      window.removeEventListener('contextmenu', function (event) {
        event.preventDefault();
      });
    }
  }, [])
  useEffect(() => {
    // to check whether loader is enabled
    if (loaderSelector && loaderSelector.isFetching) {
      setLoaderState(loaderSelector.isFetching.isFetching);
    }
    // to check whether error is received from api request
    if (errorSelector && errorSelector.errors) {
      setError(errorSelector.errors);
    }

    // To check exceptional handling
    if (errorSelector && errorSelector.exceptionList) {
      setExceptionList(errorSelector.exceptionList);
    }
    const exceptions:  KeyWithAnyModel = errorSelector.exceptionList;
    if(errorSelector.errors.length > 0 || (exceptions && exceptions.error_header)){
      trackEvents.triggerAdobeEvent('formError');
    }
   
    window.addEventListener("unload", function () {
      trackEvents.triggerAdobeEvent('formAbandonment', 'BrowserClose')
    })
  }, [loaderSelector, errorSelector]);

  useEffect(()=>{
    if (isIdle) {
      // eslint-disable-next-line @typescript-eslint/no-unused-expressions
      if (!openIdlePopUp) {
        setOpenIdlePopUp(true);
      }
    }
  },[isIdle])

  const onIdle = () => {   
    loaderState === true ? onActive() : setIsIdle(true);
  };
  const onActive = () => {
    setIsIdle(false);
  };
  const handlePopUpClick = () => {
    setOpenIdlePopUp(false);
  };
  return (
    <>
      {/* Idle time out */}
      <ActivityDetector
        enabled={true}
        timeout={
          Number(`${process.env.REACT_APP_RTOB_APP_IDLE_TIMEOUT_DURATION}`) *
          10000
        }
        onIdle={onIdle}
        onActive={onActive}
        name="default"
      />

      {openIdlePopUp && (
        <IdleTimeOutModel handlePopUpClick={handlePopUpClick} />
      )}

      <BrowserRouter basename="/">
        <Main />
        {exceptionList.length !== 0 && (
          <DynamicModel errorList={exceptionList} />
        )}
        {error.length > 0 ? (
          <Model name="globalError" />
        ) : (
          loaderState && <Spinner />
        )}
      </BrowserRouter>
    </>
  );
};
export default App;





import React from "react";
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import { Provider } from "react-redux";
import { createStore } from "redux";
import { MemoryRouter } from "react-router-dom";
import { StoreModel } from "../utils/model/common-model";
import App from "../App";
import trackEvents from "../services/track-events";
import ActivityDetector from "react-activity-detector";

// Mock external dependencies
jest.mock("../services/track-events", () => ({
  triggerAdobeEvent: jest.fn(),
}));

jest.mock("react-activity-detector", () => ({
  __esModule: true,
  default: jest.fn(() => null),
}));

jest.mock("../shared/components/model/idle-time-out", () => () => (
  <div data-testid="idle-popup">Idle Timeout Modal</div>
));

jest.mock("../shared/components/spinner/spinner", () => () => (
  <div data-testid="spinner">Loading...</div>
));

jest.mock("../shared/components/model/dynamic-model", () => () => (
  <div data-testid="error-modal">Error Modal</div>
));

jest.mock("../shared/components/model/model", () => () => (
  <div data-testid="global-error-modal">Global Error Modal</div>
));

jest.mock("../router/main", () => () => <div data-testid="main-component">Main Component</div>);

// Mock store setup
const initialState: StoreModel = {
  loader: { isFetching: false },
  error: { errors: [], exceptionList: {} },
};

const mockStore = (state = initialState) =>
  createStore((s) => s || state);

// Setup environment variable
process.env.REACT_APP_RTOB_APP_IDLE_TIMEOUT_DURATION = "60";

describe("App Component", () => {
  it("renders the main component", () => {
    render(
      <Provider store={mockStore()}>
        <MemoryRouter>
          <App />
        </MemoryRouter>
      </Provider>
    );

    expect(screen.getByTestId("main-component")).toBeInTheDocument();
  });

  it("displays loader when fetching", () => {
    const store = mockStore({
      loader: { isFetching: true },
      error: { errors: [], exceptionList: {} },
    });

    render(
      <Provider store={store}>
        <MemoryRouter>
          <App />
        </MemoryRouter>
      </Provider>
    );

    expect(screen.getByTestId("spinner")).toBeInTheDocument();
  });

  it("displays error modal when there are errors", () => {
    const store = mockStore({
      loader: { isFetching: false },
      error: { errors: ["Some error"], exceptionList: {} },
    });

    render(
      <Provider store={store}>
        <MemoryRouter>
          <App />
        </MemoryRouter>
      </Provider>
    );

    expect(screen.getByTestId("global-error-modal")).toBeInTheDocument();
  });

  it("displays dynamic error modal when there are exceptions", () => {
    const store = mockStore({
      loader: { isFetching: false },
      error: { errors: [], exceptionList: { error_header: "Exception!" } },
    });

    render(
      <Provider store={store}>
        <MemoryRouter>
          <App />
        </MemoryRouter>
      </Provider>
    );

    expect(screen.getByTestId("error-modal")).toBeInTheDocument();
  });

  it("tracks form abandonment on unload", () => {
    render(
      <Provider store={mockStore()}>
        <MemoryRouter>
          <App />
        </MemoryRouter>
      </Provider>
    );

    fireEvent(window, new Event("unload"));

    expect(trackEvents.triggerAdobeEvent).toHaveBeenCalledWith(
      "formAbandonment",
      "BrowserClose"
    );
  });

  it("disables right-click", () => {
    render(
      <Provider store={mockStore()}>
        <MemoryRouter>
          <App />
        </MemoryRouter>
      </Provider>
    );

    const contextMenuEvent = new MouseEvent("contextmenu", {
      bubbles: true,
      cancelable: true,
    });

    fireEvent(window, contextMenuEvent);
    expect(contextMenuEvent.defaultPrevented).toBe(true);
  });

  it("triggers idle timeout popup", async () => {
    let onIdleCallback: () => void;
    (ActivityDetector as jest.Mock).mockImplementation(({ onIdle }) => {
      onIdleCallback = onIdle;
      return null;
    });

    render(
      <Provider store={mockStore()}>
        <MemoryRouter>
          <App />
        </MemoryRouter>
      </Provider>
    );

    // Simulate idle timeout
    onIdleCallback();

    await waitFor(() => {
      expect(screen.getByTestId("idle-popup")).toBeInTheDocument();
    });
  });
});
