// Import necessary modules
import { nextStage } from './path-to-your-function'; // Adjust the path to your function file
import { 
    postTMXUserSession, 
    postFinalAcknowledge, 
    postDocSaveData 
} from './api'; // Mock these API calls
import { dispatchLoader, preApprovalAction, stagesAction } from './actions'; // Mock these actions
import { CONSTANTS, stageSelector } from './constants'; // Mock these constants

jest.mock('./api'); // Mock the API module
jest.mock('./actions'); // Mock actions
jest.mock('./constants', () => ({
    CONSTANTS: { STAGE_NAMES: { LD_1: 'LD_1' } },
    stageSelector: [{ stageInfo: { id: 'dummy-stage-info' } }],
}));

// Mock dispatch
const dispatch = jest.fn();

// Mock API responses
const mockPostTMXUserSession = {
    status: 200,
    data: { review_status: 'pass' },
};

const mockPostFinalAcknowledge = {
    status: 202,
};

const mockPostDocSaveData = {
    data: {
        applicants: [{ id: 1, name: 'John Doe' }],
        application: { id: 123, name: 'Test Application' },
        applicant_documents: [{ id: 'doc-1', type: 'passport' }],
    },
};

// Test suite
describe('nextStage function', () => {
    beforeEach(() => {
        jest.clearAllMocks();
    });

    it('should successfully complete the next stage process', async () => {
        // Mock the API calls
        postTMXUserSession.mockResolvedValue(mockPostTMXUserSession);
        postFinalAcknowledge.mockResolvedValue(mockPostFinalAcknowledge);
        postDocSaveData.mockResolvedValue(mockPostDocSaveData);

        // Call the function
        await nextStage();

        // Assertions for dispatchLoader
        expect(dispatch).toHaveBeenCalledWith(dispatchLoader(true));
        expect(dispatch).toHaveBeenCalledWith(dispatchLoader(false));

        // Assertions for postTMXUserSession
        expect(postTMXUserSession).toHaveBeenCalledWith('channel_reference');
        expect(postFinalAcknowledge).toHaveBeenCalledWith('channel_reference');

        // Assertions for postDocSaveData
        expect(postDocSaveData).toHaveBeenCalledWith(
            'documentData',
            'HKIDQRCodeData',
            'zolozDocumentData'
        );

        // Assertions for dispatching actions
        expect(dispatch).toHaveBeenCalledWith(preApprovalAction.setCurrentStage('PD-3'));
        expect(dispatch).toHaveBeenCalledWith(stagesAction.updateStageId(CONSTANTS.STAGE_NAMES.LD_1));

        // Assertions for stage data
        const expectedStageData = {
            applicants: mockPostDocSaveData.data.applicants,
            application: mockPostDocSaveData.data.application,
            applicant_documents: mockPostDocSaveData.data.applicant_documents,
        };

        expect(dispatch).toHaveBeenCalledWith(stagesAction.getStage({
            id: CONSTANTS.STAGE_NAMES.LD_1,
            formConfig: expectedStageData,
        }));
    });

    it('should skip processing if postTMXUserSession fails or review_status is not "pass"', async () => {
        // Mock a failed session response
        postTMXUserSession.mockResolvedValue({ status: 400 });

        // Call the function
        await nextStage();

        // Ensure further actions are not triggered
        expect(postFinalAcknowledge).not.toHaveBeenCalled();
        expect(postDocSaveData).not.toHaveBeenCalled();

        // Ensure dispatchLoader is called correctly
        expect(dispatch).toHaveBeenCalledWith(dispatchLoader(true));
        expect(dispatch).toHaveBeenCalledWith(dispatchLoader(false));
    });

    it('should skip processing if postFinalAcknowledge fails', async () => {
        // Mock responses
        postTMXUserSession.mockResolvedValue(mockPostTMXUserSession);
        postFinalAcknowledge.mockResolvedValue({ status: 400 });

        // Call the function
        await nextStage();

        // Ensure postDocSaveData is not called
        expect(postDocSaveData).not.toHaveBeenCalled();

        // Ensure dispatchLoader is called correctly
        expect(dispatch).toHaveBeenCalledWith(dispatchLoader(true));
        expect(dispatch).toHaveBeenCalledWith(dispatchLoader(false));
    });
});
